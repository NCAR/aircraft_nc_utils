#! /usr/bin/env python3
#######################################################################
# Python 3 based netCDF to ASCII converter with GUI
#
# Generates plain text, ICARTT or AMES header files with multiple
# delimiter, fill value, date, and time formats.
#
# Program consists of two classes 1) "gui" and 2) "nc2asc_CL"
# Function names include "_GUI" if the function is only used within
# the GUI.
#
# Update June 2022 (TMT):Main function determines whether the mode
# is GUI or command line based on the number of arguments included.
#
# Copyright University Corporation for Atmospheric Research (2021-2022)
#######################################################################

import os
from os.path import exists
import sys
import argparse
import pandas as pd
import numpy as np
import math
from datetime import datetime
from warnings import simplefilter, filterwarnings
from PyQt5 import QtGui, QtCore, QtWidgets
from PyQt5.QtCore import Qt
import xarray as xr
import traceback
from PyQt5.QtWidgets import QTextBrowser, QGroupBox, QGridLayout, QWidget, QHBoxLayout, QFrame, QScrollBar, QToolBar, QMessageBox, QFileDialog, QTableWidgetItem, QVBoxLayout, QMenu, QMenuBar, QMainWindow, QAction, qApp, QApplication

simplefilter(action="ignore", category=pd.errors.PerformanceWarning)
filterwarnings(action='ignore', category=DeprecationWarning, message='`np.bool` is a deprecated alias')


class gui(QMainWindow):

    def __init__(self):

        super(gui, self).__init__()

        self.initUI()

    #########################################################################
    # Define layout of gui
    # Set up the fields, table, buttons, and menu
    # nc2asc uses a combination of absolute positioning and QGridLayout
    # Components of QGridLayout are added to layout before absolute position
    #########################################################################
    def initUI(self):

        # bold font to help with organization of processing options
        myFont = QtGui.QFont()
        myFont.setBold(True)
        self.histo = False
        self.cellsize_dict = {}
        self.variables_extract_batch = []

        #####################################################################
        # QGridLayout: Variable table and selection / deselection options
        #####################################################################
        # button to select all variables
        self.varbtn = QtWidgets.QPushButton('Select All', self)
        self.varbtn.move(600, 30)
        self.varbtn.clicked.connect(self.loadVars_GUI)
        self.varbtn.clicked.connect(self.selectAll_GUI)
        # button to de-select all variables
        self.varbtn2 = QtWidgets.QPushButton('Clear All', self)
        self.varbtn2.move(700, 30)
        self.varbtn2.clicked.connect(self.loadVars_GUI)
        self.varbtn2.clicked.connect(self.deselectAll_GUI)
        # button to remove current variable
        self.deselectvar = QtWidgets.QPushButton('Remove Var', self)
        self.deselectvar.move(800, 30)
        self.deselectvar.clicked.connect(self.deselectVar_GUI)
        # variable table and buttons with labels
        varlabel = QtWidgets.QLabel(self)
        varlabel.setText('Click Vars:')
        varlabel.move(500, 30)
        varlabel.setFont(myFont)
        self.var = QtWidgets.QTableWidget(self)
        self.var.setColumnCount(3)
        header = self.var.horizontalHeader()
        header.setSectionResizeMode(0, QtWidgets.QHeaderView.ResizeToContents)
        self.var.setColumnWidth(2, 100)
        header.setSectionResizeMode(2, QtWidgets.QHeaderView.Stretch)
        self.var.setRowCount(15)
        self.var.move(500, 60)
        self.var.resize(400, 430)
        self.var.setHorizontalHeaderLabels(['Var', 'Units', 'Long Name'])
        self.var.clicked.connect(self.selectVars_GUI)
        self.guiMode = True
        #self.version = 'RA'

        #####################################################################
        # QGridLayout: Output preview options
        #####################################################################
        # output preview label
        outputpreviewlabel = QtWidgets.QLabel(self)
        outputpreviewlabel.move(20, 470)
        outputpreviewlabel.setText('Preview:')
        outputpreviewlabel.setFont(myFont)
        # output preview field with horizontal scroll bar
        self.outputpreview = QtWidgets.QTextEdit(self)
        self.outputpreview.move(20, 500)
        self.outputpreview.resize(880, 150)
        self.outputpreview.setLineWrapMode(QtWidgets.QTextEdit.NoWrap)

        # process button calls writeData function
        self.processbtn = QtWidgets.QPushButton('Convert File', self)
        self.processbtn.resize(self.processbtn.sizeHint())
        self.processbtn.move(20, 670)
        self.processbtn.clicked.connect(self.writeData)

        #####################################################################
        # Create a grid layout that can be populated with widgets
        #####################################################################

        grid = QGridLayout()
        grid.setSpacing(10)
        # populate the grid layout with the variable table
        grid.addWidget(self.var, 0, 5, 6, 5)
        # populate the grid layout with the output preview field
        grid.addWidget(self.outputpreview, 7, 0, 2, 10)
        # populate the grid layout with buttons for var selection
        grid.addWidget(self.varbtn, 0, 10)
        grid.addWidget(self.varbtn2, 1, 10)
        grid.addWidget(self.deselectvar, 2, 10)
        # populate the grid layout with the processing button
        grid.addWidget(self.processbtn, 11, 0)
        wid = QtWidgets.QWidget(self)
        self.setCentralWidget(wid)
        wid.setLayout(grid)

        #####################################################################
        # Input file and output dir / file fields
        #####################################################################
        # define input file box and label
        self.inputfilebox = QtWidgets.QLineEdit(self)
        self.inputfilebox.move(140, 40)
        self.inputfilebox.resize(350, 20)
        self.inputlabel = QtWidgets.QLabel(self)
        self.inputlabel.setText('Input File')
        self.inputlabel.move(75, 40)
        # define output dir and file
        # output dir
        self.outputdirlabel = QtWidgets.QLabel(self)
        self.outputdirlabel.setText('Output Directory')
        self.outputdirlabel.move(30, 70)
        self.outputdirbox = QtWidgets.QLineEdit(self)
        self.outputdirbox.move(140, 70)
        self.outputdirbox.resize(350, 20)
        # output file
        self.outputlabel = QtWidgets.QLabel(self)
        self.outputlabel.setText('Output Filename:')
        self.outputlabel.move(30, 100)
        self.outputfilebox = QtWidgets.QLineEdit(self)
        self.outputfilebox.move(140, 100)
        self.outputfilebox.resize(350, 20)

        #####################################################################
        # Start time, end time, and averaging options
        #####################################################################
        # fields for start and end time
        timeselectionlabel = QtWidgets.QLabel(self)
        timeselectionlabel.setText('Time Options:')
        timeselectionlabel.move(20, 140)
        startlab = QtWidgets.QLabel(self)
        startlab.setText('Start:')
        endlab = QtWidgets.QLabel(self)
        endlab.setText('End:')
        startlab.move(100, 160)
        endlab.move(100, 180)
        self.start = QtWidgets.QLineEdit(self)
        self.end = QtWidgets.QLineEdit(self)
        self.start.move(140, 165)
        self.start.resize(140, 20)
        self.end.move(140, 185)
        self.end.resize(140, 20)
        # averaging label and box
        averaginglabel = QtWidgets.QLabel(self)
        averaginglabel.setText('Averaging (s):')
        averaginglabel.move(100, 200)
        averagingnote = QtWidgets.QLabel(self)
        averagingnote.move(280, 200)
        averagingnote.resize(300, 20)
        self.averagingbox = QtWidgets.QLineEdit(self)
        self.averagingbox.move(220, 205)
        self.averagingbox.resize(60, 20)
        # button to update preview based on time options
        self.outputpreviewbutton = QtWidgets.QPushButton('Update Preview', self)
        self.outputpreviewbutton.move(300, 200)
        self.outputpreviewbutton.clicked.connect(self.selectVars_GUI)

        #####################################################################
        # Processing options section
        #####################################################################
        processinglabel = QtWidgets.QLabel(self)
        processinglabel.setText('Output Options:')
        processinglabel.move(20, 240)
        processinglabel.resize(100, 20)
        processinglabel.setFont(myFont)

        #####################################################################
        # Date format options
        #####################################################################
        # radio buttons for date
        dateformatlabel = QtWidgets.QLabel(self)
        dateformatlabel.setText('Date Format:')
        dateformatlabel.move(20, 260)
        dateformatlabel.setFont(myFont)
        self.date1 = QtWidgets.QRadioButton(self)
        self.date1.setText('yyyy-mm-dd')
        self.date1.move(20, 280)
        self.date2 = QtWidgets.QRadioButton(self)
        self.date2.setText('yyyy mm dd')
        self.date2.move(20, 300)
        self.date3 = QtWidgets.QRadioButton(self)
        self.date3.setText('NoDate')
        self.date3.move(20, 320)
        dategroup = QtWidgets.QButtonGroup(self)
        dategroup.addButton(self.date1)
        dategroup.addButton(self.date2)
        dategroup.addButton(self.date3)
        # have the default be date 1 but update the preview when any are clicked
        self.date1.setChecked(True)
        self.date1.clicked.connect(self.selectVars_GUI)
        self.date2.clicked.connect(self.selectVars_GUI)
        self.date3.clicked.connect(self.selectVars_GUI)

        #####################################################################
        # Time format options
        #####################################################################
        # radio buttons for time
        timeformatlabel = QtWidgets.QLabel(self)
        timeformatlabel.setText('Time Format:')
        timeformatlabel.move(200, 260)
        timeformatlabel.setFont(myFont)
        self.time1 = QtWidgets.QRadioButton(self)
        self.time1.setText('hh:mm:ss')
        self.time1.move(200, 280)
        self.time2 = QtWidgets.QRadioButton(self)
        self.time2.setText('hh mm ss')
        self.time2.move(200, 300)
        self.time3 = QtWidgets.QRadioButton(self)
        self.time3.setText('SecOfDay')
        self.time3.move(200, 320)
        timegroup = QtWidgets.QButtonGroup(self)
        timegroup.addButton(self.time1)
        timegroup.addButton(self.time2)
        timegroup.addButton(self.time3)
        # have default be time 1 but update the preview when any are clicked
        self.time1.setChecked(True)
        self.time1.clicked.connect(self.selectVars_GUI)
        self.time2.clicked.connect(self.selectVars_GUI)
        self.time3.clicked.connect(self.selectVars_GUI)

        #####################################################################
        # Delimiter format options
        #####################################################################
        # radio buttons for the delimiter
        delimiterlabel = QtWidgets.QLabel(self)
        delimiterlabel.setText('Delimiter:')
        delimiterlabel.move(380, 260)
        delimiterlabel.setFont(myFont)
        self.comma = QtWidgets.QRadioButton(self)
        self.comma.setText('Comma')
        self.comma.move(380, 280)
        self.space = QtWidgets.QRadioButton(self)
        self.space.setText('Space')
        self.space.move(380, 300)
        delimitergroup = QtWidgets.QButtonGroup(self)
        delimitergroup.addButton(self.comma)
        delimitergroup.addButton(self.space)
        # have default be comma delimited but update the preview when any are clicked
        self.comma.setChecked(True)
        self.comma.clicked.connect(self.selectVars_GUI)
        self.space.clicked.connect(self.selectVars_GUI)

        #####################################################################
        # Fill value format options
        ####################################################################
        # radio buttons for the fill value
        fillvaluelabel = QtWidgets.QLabel(self)
        fillvaluelabel.setText('Fill Value:')
        fillvaluelabel.move(20, 360)
        fillvaluelabel.setFont(myFont)
        self.fillvalue1 = QtWidgets.QRadioButton(self)
        self.fillvalue1.setText('-32767.0')
        self.fillvalue1.move(20, 380)
        self.fillvalue2 = QtWidgets.QRadioButton(self)
        self.fillvalue2.setText('Blank')
        self.fillvalue2.move(20, 400)
        self.fillvalue3 = QtWidgets.QRadioButton(self)
        self.fillvalue3.setText('Replicate')
        self.fillvalue3.move(20, 420)
        fillvaluegroup = QtWidgets.QButtonGroup(self)
        fillvaluegroup.addButton(self.fillvalue1)
        fillvaluegroup.addButton(self.fillvalue2)
        fillvaluegroup.addButton(self.fillvalue3)
        # have default be fill value 1 but update the preview when any are clicked
        self.fillvalue1.setChecked(True)
        self.fillvalue1.clicked.connect(self.selectVars_GUI)
        self.fillvalue2.clicked.connect(self.selectVars_GUI)
        self.fillvalue3.clicked.connect(self.selectVars_GUI)

        #####################################################################
        # Header format options
        #####################################################################
        # radio buttons for header
        headerformatlabel = QtWidgets.QLabel(self)
        headerformatlabel.setText('Header:')
        headerformatlabel.move(200, 360)
        headerformatlabel.setFont(myFont)
        self.header1 = QtWidgets.QRadioButton(self)
        self.header1.setText('Plain')
        self.header1.move(200, 380)
        self.header2 = QtWidgets.QRadioButton(self)
        self.header2.setText('ICARTT')
        self.header2.move(200, 400)
        self.header3 = QtWidgets.QRadioButton(self)
        self.header3.setText('AMES DEF')
        self.header3.move(200, 420)
        headergroup = QtWidgets.QButtonGroup(self)
        headergroup.addButton(self.header1)
        headergroup.addButton(self.header2)
        headergroup.addButton(self.header3)
        # have the default be header 1 (plain) but update the preview when any are clicked
        self.header1.setChecked(True)
        self.header2.clicked.connect(self.ICARTT_AMES_toggle_GUI)
        self.header1.clicked.connect(self.selectVars_GUI)
        self.header2.clicked.connect(self.selectVars_GUI)
        self.header3.clicked.connect(self.ICARTT_AMES_toggle_GUI)
        self.header3.clicked.connect(self.selectVars_GUI)
        self.header2.clicked.connect(self.ICARTTfilename)

        #####################################################################
        # Menu options
        #####################################################################
        mainMenu = self.menuBar()
        fileMenu = mainMenu.addMenu('File')
        helpMenu = mainMenu.addMenu('Help')
        importFile = QAction('Open NetCDF File', self)
        saveBatchFile = QAction('Save Batch File', self)
        readBatchFile = QAction('Read Batch File', self)
        exit = QAction('Exit', self)
        readme = QAction('nc2asc GitHub readme', self)
        fileMenu.addAction(importFile)
        fileMenu.addAction(saveBatchFile)
        fileMenu.addAction(readBatchFile)
        fileMenu.addAction(exit)
        # connect the menu option File > Import NetCDF File to the data functions
        importFile.triggered.connect(self.loadData_GUI)
        importFile.triggered.connect(self.formatData)
        importFile.triggered.connect(self.loadVars_GUI)
        # connect the menu option File > Read Batch file to the function
        readBatchFile.triggered.connect(self.readBatchFile)
        # connect the exit menu option to the close function
        exit.triggered.connect(self.close)
        # connect the save batch file menu option to the function
        saveBatchFile.triggered.connect(self.saveBatchFile_GUI)

        # help launches readme
        helpMenu.addAction(readme)
        readme.triggered.connect(self.openhelp)

        #####################################################################
        # General setup options
        #####################################################################
        # changing the background color to gray
        self.setGeometry(100, 100, 1080, 720)
        self.setWindowTitle('NCAR/EOL RAF Aircraft NetCDF to ASCII File Converter')
        p = self.palette()
        p.setColor(self.backgroundRole(), Qt.white)
        self.setPalette(p)
        self.show()
#############################################################################
# End UI Setup ##############################################################
#############################################################################
    def _log_exception(self, exception):
            """Log exception with traceback."""
            print(exception)
            print(traceback.format_exc())
    def openhelp(self):
        url = QtCore.QUrl('https://github.com/NCAR/aircraft_nc_utils/blob/master/nc2asc/README.md')
        if not QtGui.QDesktopServices.openUrl(url):
            QtGui.QMessageBox.warning(self, 'readme', 'Could not open url')

    #########################################################################
    # Function definitions for batch file saving and reading
    #########################################################################

    # Define function to save a batch file "batchfile" from within GUI
    def saveBatchFile_GUI(self):

        # check to ensure the user has already loaded a NetCDF
        if len(self.inputfilebox.text()) == 0:
            no_savebatch = QMessageBox()
            # if no NetCDF loaded, display error message
            no_savebatch.setWindowTitle('Error')
            no_savebatch.setText('Cannot Save Batchfile, Need Input File!')
            x = no_savebatch.exec_()
        else:
            buttonReply = 'No'
            if exists(str(self.head) + '/batchfile'):
                buttonReply = QMessageBox.question(self, 'Warning', "Batch file already exists. Overwrite?", QMessageBox.Yes | QMessageBox.No)
            else:
                pass
            if buttonReply == QMessageBox.No:
                print('buttonReply == QMessageBox.No')
            else:
                try:
                    # if NetCDF file has been loaded start creating batch file
                    self.batchfile = str(self.outputdirbox.text()) + '/batchfile'
                    os.system('touch ' + self.batchfile)
                    self.batchfile = open(self.batchfile, "w")

                    # get the output directory and filename from the gui
                    self.batchfile.write('if=' + self.input_file + '\n')
                    self.batchfile.write('of=' + str(self.outputdirbox.text()) + '/' + str(self.outputfilebox.text()) + '\n\n')

                    # determine the settings from the gui to inlude in the batch file
                    # check which header to include in the batch file
                    if self.header1.isChecked():
                        self.batchfile.write('hd=Plain\n')
                    elif self.header2.isChecked():
                        self.batchfile.write('hd=ICARTT\n')
                    elif self.header3.isChecked():
                        self.batchfile.write('hd=AMES\n')

                    # determine averaing to write to the batch file
                    averagingbox_text = str(self.averagingbox.text())
                    self.batchfile.write('avg='+averagingbox_text+'\n')

                    # determine date format to write to the batch file
                    if self.date1.isChecked():
                        self.batchfile.write('dt=yyyy-mm-dd\n')
                    elif self.date2.isChecked():
                        self.batchfile.write('dt=yyyy mm dd\n')
                    elif self.date3.isChecked():
                        self.batchfile.write('dt=NoDate\n')

                    # determine time format to write to the batch file
                    if self.time1.isChecked():
                        self.batchfile.write('tm=hh:mm:ss\n')
                    elif self.time2.isChecked():
                        self.batchfile.write('tm=hh mm ss\n')
                    elif self.time3.isChecked():
                        self.batchfile.write('tm=SecOfDay\n')

                    # determine delimieter to write to the batch file
                    if self.comma.isChecked():
                        self.batchfile.write('sp=comma\n')
                    elif self.space.isChecked():
                        self.batchfile.write('sp=space\n')

                    # determine the fillvalue to write to the batch file
                    if self.fillvalue1.isChecked():
                        self.batchfile.write('fv=-32767\n')
                    elif self.fillvalue2.isChecked():
                        self.batchfile.write('fv=blank\n')
                    elif self.fillvalue3.isChecked():
                        self.batchfile.write('fv=replicate\n')

                    # determine the time interval to write to the batch file
                    # by default the self.start/end.text() method will return the full file
                    self.batchfile.write('ti=X,X\n')

                    # in order to display vars on separate lines to align with
                    # nimbus batch file conventions, split by two spaces
                    for i in self.variables_extract:
                        try:
                            self.batchfile.write('Vars=' + i + '\n')
                        except Exception:
                            pass
                    self.batchfile.close

                    # notify user that batch file has been written
                    savebatch = QMessageBox()
                    savebatch.setWindowTitle("Success!")
                    savebatch.setText("Batch File Successfully Created! Close program and check output directory")
                    x = savebatch.exec_()
                except Exception as e:
                    print(e)
                    
    def process_batch_file(self, inputbatch_file):
        """Processes a batch file to extract settings and variables."""
        action_map = {
            'if=': lambda ln: self._handle_file(ln, 'input_file', 'Input'),
            'of=': lambda ln: self._handle_file(ln, 'output_file', 'Output'),
            'hd=': lambda ln: self._handle_directive(ln, 'header', self._header_map()),
            'dt=': lambda ln: self._handle_directive(ln, 'date', self._date_map()),
            'tm=': lambda ln: self._handle_directive(ln, 'time', self._time_map()),
            'sp=': lambda ln: self._handle_directive(ln, 'delimiter', self._delimiter_map()),
            'fv=': lambda ln: self._handle_directive(ln, 'fillvalue', self._fillvalue_map()),
            'version=': lambda ln: setattr(self, 'version', ln.replace('version=', '').strip()),
            'ti=': lambda ln: setattr(self, 'ti', ln[3:].strip()),
            'avg=': lambda ln: setattr(self, 'avg', self._format_avg(ln[4:])),
            'Vars=': lambda ln: self._add_variable(ln),
        }
        
        with open(inputbatch_file, 'r') as fil:
            print('****Reading Batch File****')
            for ln in fil:
                ln = ln.strip()
                for key, action in action_map.items():
                    if ln.startswith(key):
                        action(ln)
                        break
            print('Batch file processing complete.')
        
    def _header_map(self):
        return {
            'hd=Plain': ('header1', 'Plain'),
            'hd=ICARTT': ('header2', 'ICARTT'),
            'hd=AMES': ('header3', 'AMES'),
        }

    def _date_map(self):
        return {
            'dt=yyyy-mm-dd': ('date1', 'yyyy-mm-dd'),
            'dt=yyyy mm dd': ('date2', 'yyyy mm dd'),
            'dt=NoDate': ('date3', 'NoDate'),
        }

    def _time_map(self):
        return {
            'tm=hh:mm:ss': ('time1', 'hh:mm:ss'),
            'tm=hh mm ss': ('time2', 'hh mm ss'),
            'tm=SecOfDay': ('time3', 'SecOfDay'),
        }

    def _delimiter_map(self):
        return {
            'sp=comma': ('comma', 'comma'),
            'sp=space': ('space', 'space'),
        }

    def _fillvalue_map(self):
        return {
            'fv=-32767': ('fillvalue1', '-32767'),
            'fv=blank': ('fillvalue2', 'blank'),
            'fv=replicate': ('fillvalue3', 'replicate'),
        }

    def _handle_file(self, line, attr_name, file_type):
        """Prompt user to confirm file selection from batch file or use command line input."""
        batch_file_value = line.split('=')[1].strip() # extract file path from batch file line
        current_value = getattr(self, attr_name, None)

        if not current_value:
            print(f'No {file_type} file provided.')
            setattr(self, attr_name, batch_file_value) 
            ## print attr to make sure it's set
        else:
            choice = input(
                f"Would you like to use the {file_type.lower()} file from the batch file? (y/Y to confirm, any other key to keep current): "
            )
            if choice.lower() == 'y':
                setattr(self, attr_name, batch_file_value)
            else:
                print(f"Using {file_type.lower()} file from command line: {current_value}")


    def _handle_directive(self, line, attr_name, directive_map):
        """Set an attribute and toggle GUI checkbox based on a line and a directive map."""
        if line in directive_map:
            gui_attr, value = directive_map[line]
            try:
                getattr(self, gui_attr).setChecked(True)
                setattr(self, attr_name, value)
            except AttributeError:
                setattr(self, attr_name, value)

    def _add_variable(self, line):
        """Extract and add variables from a batch file line."""
        variable = line.replace('Vars=', '').replace("'", "").replace('[', '').replace(']', '').strip()
        if variable not in self.variables_extract_batch:
            self.variables_extract_batch.append(variable)

    def _format_avg(self, avg):
        """Format the averaging value from the batch file."""
        return avg.translate({ord(c): None for c in "[]='g"}).strip()[:-1]
    # Define function to read batch file and render in GUI or use in command line processing mode
    def readBatchFile(self):

        # try to get batch file from the gui prompt if in gui mode
        try:
            self.inputbatch_file = self.inputbatch_file
        except Exception:
            try:
                self.inputbatch_file, _ = QFileDialog.getOpenFileName(self, "Select a Batch file to Read", "/scr/raf_data", "filter = *")
            except Exception:
                pass
        try:
            self.process_batch_file(self.inputbatch_file)

                # update the gui fields
            try:
                self.inputfilebox.setText(self.input_file)
                self.outputdirbox.setText(os.path.dirname(self.output_file) + '/')
                self.outputfilebox.setText(os.path.basename(self.output_file))
                self.start.setText(str(self.start_time))
                self.end.setText(str(self.end_time))
                self.averagingbox.setText(self.avg)
            except Exception:
                pass

            # get data from input file field and format
            try:
                self.input_file = self.inputfilebox.text()
            except Exception:
                self.input_file = self.input_file
            self.batchfile_read = True
            try:
                
                self.formatData()
                self.asc_new_batch = self.asc[self.variables_extract_batch]
                self.asc_new =self.asc_new_batch
                #return self.batchfile_read, self.input_file, self.asc_new_batch, self.output_file, self.start_time, self.end_time
            except Exception as e:
                self._log_exception(e)
                pass
            try:
                self.loadVars_GUI()
            except Exception as e:
                self._log_exception(e)
                pass

            try:
                for i in range(0, self.row_count):
                    for j in self.asc_new_batch:
                        if j[0] == self.var.item(i, 0).text():
                            print('success')
                            self.var.item(i, 0).text()
                            self.var.item(i, 0).setBackground(QtGui.QColor(255, 0, 255))
                        else:
                            pass
            except Exception as e:
                self._log_exception(e)
            try:
                self.previewData_GUI()
            except Exception as e :
                self._log_exception(e)
                pass
        except Exception as e:
            self._log_exception(e)
            pass

#######################################################################
# Function definitions for data loading, formatting, and processing
#######################################################################
    # Define function to load an input netCDF data file into the GUI
    def loadData_GUI(self):

        try:
            # pop up box to select the input file for processing
            self.input_file, _ = QFileDialog.getOpenFileName(self, "Select a File to Convert", "/scr/raf_data", "filter = nc(*.nc)")
            self.inputfilebox.setText(str(self.input_file))
            # use the path to the input file to pre-populate the output dir and filename
            self.head, self.tail = os.path.split(self.input_file)
            # populate the output directory text from the input directory
            self.outputdirbox.setText(str(self.head + '/'))
            # populate the output file text from the input filename with .txt extension
            self.tail = os.path.splitext(self.tail)[0] + '.txt'
            self.outputfilebox.setText(str(self.tail))
        except Exception:
            # if there is an error loading the NetCDF file, notify the user in a popup
            no_process = QMessageBox()
            no_process.setWindowTitle("Error")
            no_process.setText("Cannot Process!")
            x = no_process.exec_()
            
    def parse_vars(self,nc):
        for i in nc.variables:
            # handle only time dimension variables
            dims = str(nc[i].dims)
            if dims == "('Time',)":
                output = nc[i].values
                # append self.asc with vars in file
                self.asc[i] = pd.DataFrame(output,columns=[i])   
                # append self.units with netcdf attribute units
                try:
                    units = nc[i].units
                    self.units[i] = pd.Series([units])
                except AttributeError:
                    self.units[i] = pd.Series([''])
                # append self.long_name with netcdf attribute long_name
                long_name = nc[i].attrs['long_name']
                self.long_name[i] = pd.Series([long_name])
                # append self.variables with netcdf variable names
                variables = i
                self.variables[i] = pd.Series([variables])
                var_list = [i] * len(self.asc[i].columns) ## Add the variable name to the column header
                self.asc[i].columns = pd.MultiIndex.from_tuples(zip(var_list,self.asc[i].columns, [units]))
                
            elif "sps1" in dims:
                self.histo = True
                histo_output = pd.DataFrame(nc[i][:, 0, :].values)
                self.asc[i] = pd.DataFrame(histo_output)
                # append self.units with netcdf attribute units
                units = nc[i].attrs['units']
                self.units[i] = pd.Series([units])
                # append self.long_name with netcdf attribute long_name
                long_name = nc[i].attrs['long_name']
                self.long_name[i] = pd.Series([long_name])
                # append self.variables with netcdf variable names
                variables = i
                self.variables[i] = pd.Series([variables])
                bin_cols =[]
                for num in self.asc[i].columns:
                    #check if list is empty
                    bin_cols.append(i+'_'+str(num))
                #print(bin_cols)
                self.asc[i].columns = pd.MultiIndex.from_tuples(zip(bin_cols, self.asc[i].columns, self.asc[i].columns))
                try:
                    cellsize = nc[i].attrs['CellSizes'] #TODO: Add cellsize to the ICARTT header and only have bin number in the column header
                    self.cellsize_dict[i] = cellsize
                    var_list = [i] * len(self.asc[i].columns) 
                    ## Add the bin number to variable name
                except KeyError:
                    var_list = [i] * len(self.asc[i].columns) ## Add the variable name to the column header
                
            else:
                pass
    # Define function to format the data loaded
    def formatData(self):

        try:
            # read in the input file
            #nc = netCDF4.Dataset(self.input_file, mode='r')
            nc = xr.open_dataset(self.input_file,decode_times=False)
            # create an empty pandas series to hold variables
            self.variables_extract = pd.Series(dtype=str)
            # create empty dicts
            self.asc = {}
            self.units = {}
            self.long_name = {}
            self.variables = {}
            self.fileheader = {}
            self.project_manager = 'Patrick Veres, Pavel Romashkin'
            try:
                self.tail_number = nc.attrs['Platform']
            except KeyError:
                self.tail_number = nc.attrs['platform']
            if self.tail_number == 'N677F':
                self.platform = 'GV'
            elif self.tail_number == 'N130AR':
                self.platform = 'C130'
            self.project_name = nc.attrs['project']
            self.today = str(datetime.today().strftime('%Y, %m, %d'))
            self.today = self.today.replace('-', ', ')

            self.parse_vars(nc)
            # concatenate
            self.asc = pd.concat(self.asc, axis=1, ignore_index=False)
            # create an object to store the NetCDF variable time
            self.dtime = nc.variables['Time']
            # use num2date to setup dtime object
            self.dtime = xr.coding.times.decode_cf_datetime(nc['Time'], nc['Time'].attrs['units'])
            self.dtime = pd.Series(self.dtime).astype(str)
            self.dtime_sep = self.dtime.str.split(' ', expand=True)
            # create separate date and time series for combination in previewData and writeData
            self.dtime_date = self.dtime_sep[0]
            self.dtime_time = self.dtime_sep[1]
            # concatenate the units, long_name, variables, and header
            self.units = pd.concat(self.units, axis=0, ignore_index=True)
            self.long_name = pd.concat(self.long_name, axis=0, ignore_index=True)
            self.variables = pd.concat(self.variables, axis=0, ignore_index=True)
            self.fileheader = pd.concat([self.variables, self.units, self.long_name], axis=1, ignore_index=True)
            # subset the start and end time from the dtime objet by position
            self.start_time = self.dtime.iloc[0]
            self.end_time = self.dtime.iloc[-1]
            try:
                # populate the start_time and end_time fields in the gui
                self.start.setText(self.start_time)
                self.end.setText(self.end_time)
            except Exception:
                pass
            return self.start_time, self.end_time, self.input_file, self.units, self.asc, self.fileheader, self.dtime_date, self.dtime_time, self.dtime
        except Exception:
            print(traceback.format_exc())
            print('Error in extracting variable in ' + str(self.input_file))

    # Define function to populate variables in the table
    def loadVars_GUI(self):

        try:
            
            self.formatData()
            self.header_np = self.fileheader.to_numpy()
            self.row_count = (len(self.header_np))
            self.column_count = 3
            self.var.setColumnCount(self.column_count)
            self.var.setRowCount(self.row_count)
            for row in range(self.row_count):
                for column in range(self.column_count):
                    self.item = str(self.header_np[row, column])
                    self.var.setItem(row, column, QTableWidgetItem(self.item))
        except Exception as e:
            print(e)
            print(traceback.format_exc())
            print("error setting up the table")

    # Define function to select all variables in a NetCDF file
    def selectAll_GUI(self):

        self.formatData()
        self.asc_new = {}
        # iterate over the variables in the list
        try:
            for i in range(self.row_count):
                self.var.item(i, 0).setBackground(QtGui.QColor(71, 145, 209))
            del self.asc_new
            self.asc = self.asc
            self.previewData_GUI()
        except Exception:
            no_data = QMessageBox()
            no_data.setWindowTitle("Error")
            no_data.setText("There is no data to select all!")
            x = no_data.exec_()

    # Define function to deselect all variables, start from none
    def deselectAll_GUI(self):

        self.formatData()
        self.asc_new = {}
        self.loadVars_GUI()
        try:
            for i in range(self.row_count):
                self.var.item(i, 0).setBackground(QtGui.QColor(255, 255, 255))
            self.outputfilebox.setText(os.path.basename(self.output_file))
            self.outputpreview.setText('')
            self.date1.setChecked(True)
            self.time1.setChecked(True)
            self.comma.setChecked(True)
            self.fillvalue1.setChecked(True)
            self.header1.setChecked(True)
            self.averagingbox.setText('')
        except Exception:
            no_data = QMessageBox()
            no_data.setWindowTitle("Error")
            no_data.setText("Error Clearing Vars!")
            x = no_data.exec_()

    # Define function to select individual vars from list and populate fields
    def selectVars_GUI(self):

        # if there is a set of batch vars and user begins other selection, remove objects
        try:
            del(self.asc_new_batch)
            del(self.variables_extract_batch)
        except Exception as e:
            print(e)
        try:
            if self.batchfile_read:
                batchread = QMessageBox()
                batchread.setWindowTitle("Warning")
                batchread.setText("You are selecting vars after loading a batchfile! Please select vars in red if desired!")
                x = batchread.exec_()
            else:
                pass
        except Exception:
            pass

        try:
            self.output = pd.Series(self.var.item(self.var.currentRow(), 0).text())
            self.variables_extract = pd.concat([self.variables_extract, self.output], ignore_index=True)            
            self.variables_extract = self.variables_extract.drop_duplicates()
            self.asc_new = self.asc[self.variables_extract]
        except Exception as e:
            self._log_exception(e)
            pass
        try:
            self.var_selected = str(self.asc_new.columns.values.tolist())
            self.var.item(self.var.currentRow(), 0).setBackground(QtGui.QColor(71, 145, 209))
            # need to remove the unwanted characters for the batch file
            self.var_selected = self.var_selected.replace('(', '')
            self.var_selected = self.var_selected.replace(')', '')
            self.var_selected = self.var_selected.replace("'", '')
            self.var_selected = self.var_selected.replace(',', '')
            self.var_selected = self.var_selected.replace('[', '')
            self.var_selected = self.var_selected.replace(']', '')
            self.previewData_GUI()
            self.batchfile_read = False
            return self.batchfile_read, self.asc_new, self.variables_extract, self.var_selected
        except Exception:
            print(traceback.format_exc())
            print("error in getting values from table")

    # Define function to deselect (clear) all vars selected
    def deselectVar_GUI(self):

        self.checkoutput = self.var.item(self.var.currentRow(), 0).text()
        if self.checkoutput in self.variables_extract.values:
            self.variables_extract = self.variables_extract.loc[self.variables_extract.values != self.checkoutput]
            self.asc_new = self.asc.drop(self.checkoutput, axis=1)
            self.var_selected = self.var_selected.replace(self.checkoutput, '')
            self.var.item(self.var.currentRow(), 0).setBackground(QtGui.QColor(255, 255, 255))
        else:
            pass
        self.previewData_GUI()
        return self.asc_new, self.variables_extract, self.var_selected

    # Define function to switch radio buttons to align with ICARTT or AMES selection
    def ICARTT_AMES_toggle_GUI(self):

        self.time3.setChecked(True)
        self.date3.setChecked(True)
        self.comma.setChecked(True)
        self.fillvalue1.setChecked(True)

    # Define function to update the output filename to adhere to ICARTT V2 standards
    def ICARTTfilename(self):
        try:
            self.data_date = str(self.dtime_sep[0].iloc[1])
            self.data_date = self.data_date.replace('-', ', ')
        except Exception:
            pass
        self.icartt_filename_date = self.data_date.replace(', ', '')
        try:
            self.icartt_filename = self.project_name + '-CORE_' + self.platform + '_' + self.icartt_filename_date + '_' + self.version + '.ict'
        except Exception:
            self.icartt_filename = self.project_name + '-CORE_' + self.platform + '_' + self.icartt_filename_date + '_RA.ict'
        try:
            self.outputfilebox.setText(self.icartt_filename)
        except Exception:
            return self.icartt_filename

    #########################################################################
    # Define function to format ICARTT header
    # Note: if used outside of this script, multiple vars needed
    # self.dtime, self.platform, self.project_manager, self.project_name,
    # self.today, self.varNumber, self.output_file
    # also need header1.txt and header2.txt as templates
    #########################################################################
    def ICARTTHeader(self, icartt_header, lib_dir):

        # try renaming the time var to Start_UTC
        try:
            icartt_header = pd.DataFrame(icartt_header.rename(columns={'Time': 'Time_Start'}))
        except Exception:
            pass
        # get the varNumber from the # of columns in the dataframe
        self.varNumber = str(len(icartt_header.columns) - 1)
        icartt_header.to_csv(self.output_file, header=True, index=False, na_rep='-99999.0')
        try:
            self.columns = pd.DataFrame(icartt_header.columns.values.tolist())
            self.fileheader = self.fileheader.loc[self.fileheader[0].isin(self.columns[0])] 
            self.data_date = self.data_date.replace('-', ', ')
            # start going through the template text docs
            os.system('cp ' + lib_dir + '/header1.txt ./header1.tmp')
            os.system("ex -s -c '5i' -c x "'/header1.tmp')
            os.system('cp ' + lib_dir + '/header2.txt ./header2.tmp')
            # get today's date
            self.today = datetime.today().strftime('%Y, %m, %d')
            # perform the replacements on the first header file
            with open('./header1.tmp', 'r+') as f:
                lines = f.readlines()
                for i, line in enumerate(lines):
                    if line.startswith('RAF instruments on'):
                        lines[i] = lines[i].strip() + ' ' + self.platform + '\n'
                    if line.startswith('<PROJECT MANAGER>'):
                        lines[i] = self.project_manager + '\n'
                    if line.startswith('<PROJECT>'):
                        lines[i] = self.project_name + '\n'
                    if line.startswith('<YYYY, MM, DD,>'):
                        lines[i] = self.data_date + ', ' + self.today + '\n'
                    if line.startswith('<varNumber>'):
                        lines[i] = self.varNumber + '\n'
                    if line.startswith('<1.0>'):
                        lines[i] = '1.0,' * int(self.varNumber) + '\n'
                        lines[i] = lines[i].rstrip(lines[i][-1]) + '\n'
                    if line.startswith('<-99999.0>'):
                        lines[i] = '-99999.0,' * int(self.varNumber) + '\n'
                        lines[i] = lines[i].rstrip(lines[i][-1]) + '\n'
                f.seek(0)
                for line in lines:
                    f.write(line)
            # perform the replacements on the second header file
            with open('./header2.tmp', 'r+') as f:
                lines = f.readlines()
                for i, line in enumerate(lines):
                    if line.startswith('<PLATFORM>'):
                        lines[i] = 'PLATFORM: NSF/NCAR ' + self.platform + ' ' + self.tail_number + '\n'
                    if line.startswith('REVISION: RA'):
                        try:
                            lines[i] = str(line)
                            lines[i] = line.replace('RA', self.version)
                        except Exception:
                            pass
                    if line.startswith('RA: Field Data'):
                        try:
                            lines[i] = str(line) + self.version + ':' + '\n'
                        except Exception:
                            pass
                f.seek(0)
                for line in lines:
                    f.write(line)
            # combine and perform replacement on the combined header file
            self.fileheader.to_csv('./header1.tmp', mode='a', header=False, index=False)
            os.system('cat ./header1.tmp ./header2.tmp > ./header.tmp')
            with open('./header.tmp', 'r+') as f:
                lines = f.readlines()
                count = str(len(lines) + 1) + ', 1001, V02_2016' 
                for i, line in enumerate(lines):
                    if line.startswith('<ROWCOUNT>'):
                        lines[i] = count + '\n'
                f.seek(0)
                for line in lines:
                    f.write(line)
            os.system('mv ' + str(self.output_file) + ' ' + str(self.output_file) + '.tmp')
            os.system('cat ./header.tmp ' + str(self.output_file) + '.tmp >> ' + str(self.output_file))
            os.system('rm header.tmp header1.tmp header2.tmp ' + str(self.output_file) + '.tmp')
        except Exception as e:
            print(e)

    #########################################################################
    # Define function to format AMES header
    ########################################################################
    def AMESHeader(self, ames_header):

        # try renaming the time var to Start_UTC
        try:
            ames_header = pd.DataFrame(ames_header.rename(columns={'Time': 'UTs'}))
        except Exception:
            pass
        # get the varNumber from the # of columns in the dataframe
        self.varNumber = str(len(ames_header.columns)-1)
        ames_header.to_csv(self.output_file, header=True, index=False, na_rep='99999')
        lib_path = str(os.path.abspath(os.path.dirname(__file__)))
        try:
            lib_path = lib_path.replace("bin", "lib")
        except Exception:
            try:
                lib_path = './lib'
            except Exception as e:
                print(e)
        try:
            self.columns = pd.DataFrame(ames_header.columns.values.tolist())
            self.fileheader = self.fileheader.loc[self.fileheader[0].isin(self.columns[0])]
            self.data_date = str(self.dtime_sep[0].iloc[1])
            self.data_date = self.data_date.replace('-', ', ')
            # start going through the template text docs
            os.system('cp ' + lib_path + '/header1_ames.txt ' + lib_path + '/header1_ames.tmp')
            os.system("ex -s -c '5i' -c x " + lib_path + "/header1_ames.tmp")
            os.system('cp ' + lib_path + '/header2_ames.txt ' + lib_path + '/header2_ames.tmp')
            # get today's date
            self.today = datetime.today().strftime('%Y, %m, %d')
            # perform the replacements on the first header file
            with open(lib_path + '/header1_ames.tmp', 'r+') as f:
                lines = f.readlines()
                for i, line in enumerate(lines):
                    if line.startswith('Flight data from:'):
                        lines[i] = lines[i].strip() + ' ' + self.platform + '\n'
                    if line.startswith('<PROJECT MANAGER>'):
                        lines[i] = self.project_manager + '\n'
                    if line.startswith('<PROJECT>'):
                        lines[i] = self.project_name + '\n'
                    if line.startswith('<YYYY, MM, DD,>'):
                        lines[i] = self.data_date+', ' + self.today + '\n'
                    if line.startswith('<varNumber>'):
                        lines[i] = self.varNumber + '\n'
                    if line.startswith('<0.1>'):
                        lines[i] = '0.1,' * int(self.varNumber) + '\n'
                        lines[i] = lines[i][:-2] + '\n'
                    if line.startswith('<9999>'):
                        lines[i] = '9999,' * int(self.varNumber) + '\n'
                        lines[i] = lines[i][:-2] + '\n'
                f.seek(0)
                for line in lines:
                    f.write(line)
            # combine and perform replacement on the combined header file
            self.fileheader.to_csv(lib_path + '/header1_ames.tmp', mode='a', header=False, index=False)
            os.system('cat ' + lib_path + '/header1_ames.tmp ' + lib_path + '/header2_ames.tmp > ' + lib_path + '/header_ames.tmp')
            with open(lib_path + '/header_ames.tmp', 'r+') as f:
                lines = f.readlines()
                count = str(len(lines))+', 1001'
                for i, line in enumerate(lines):
                    if line.startswith('<ROWCOUNT>'):
                        lines[i] = count+'\n'
                f.seek(0)
                for line in lines:
                    f.write(line)
            os.system('mv ' + str(self.output_file) + ' ' + str(self.output_file) + '.tmp')
            os.system('cat ' + lib_path + '/header_ames.tmp ' + str(self.output_file) + '.tmp >> ' + str(self.output_file))
            os.system('rm ' + lib_path + '/header_ames.tmp ' + lib_path + '/header1_ames.tmp ' + lib_path + '/header2_ames.tmp ' + str(self.output_file) + '.tmp')
        except Exception:
            print('AMES header not created or appended to output file.')

    #########################################################################
    # Define function to notify user that processing was successful.
    #########################################################################
    def processingSuccess_GUI(self):

        processing_complete = QMessageBox()
        processing_complete.setWindowTitle("Success!")
        ret = QMessageBox.question(self, 'Success!', "Data was written to the output file.", QMessageBox.Ok)

    #########################################################################
    # Define function to format the preview portion of the output file
    #########################################################################
    def formatPreview_GUI(self):

        with open(self.output_file) as preview:
            head = str(preview.readlines()[0:10])
            head = head.replace('\\n', '\n')
            head = head.replace('\\n', '\n')
            head = head.replace('[', '')
            head = head.replace(']', '')
            head = head.replace("', '", '')
            head = head.replace("'", '')
        self.outputpreview.setText(head)

    #########################################################################
    # Define function for handling date and time
    # Formatting for previewData_GUI and writeData functions
    #########################################################################
    def timeHandler(self, datasource):

        try:
            datasource.insert(loc=0, column='Time', value=self.dtime_time)
        except Exception:
            pass
        try:
            datasource.insert(loc=0, column='Date', value=self.dtime_date)
        except Exception:
            pass
        try:
            datasource.pop('DateTime')
        except Exception:
            pass
#############################################################################
# Function previewData_GUI creates an example output based on user settings and
# populates the Preview field in the gui. It is set up to autmatically update
# based on the selection of the vars in selectVars, selectAll_GUI, or deselectAll_GUI.
#############################################################################

    #########################################################################
    # Define function to preview data output within the app
    #########################################################################
    def previewData_GUI(self):

        # assign self.asc_new or self.asc to self.preview dataframe
        try:
            try:
                self.preview = self.asc_new_batch
            except Exception:
                self.preview = self.asc_new
        except Exception:
            self.preview = self.asc
        self.preview = round(self.preview, 5)
        # get the output file from the text box
        self.output_file = os.path.join(self.outputdirbox.text(), self.outputfilebox.text())
        # get the start and end times from the text box in the gui
        start = self.start.text()
        end = self.end.text()
        try:
            # get the averaging information if it exists
            self.averaging_window = self.averagingbox.text()
            if len(self.averaging_window) != 0:
                self.averaging_window = int(self.averaging_window)
                self.preview = self.preview.rolling(self.averaging_window, min_periods=0).mean().round(decimals=0)
                self.preview = self.preview.iloc[::self.averaging_window, :]
            else:
                pass
            #################################################################
            # data and time combination checks for preview field
            ################################################################
            if self.date1.isChecked() and self.time1.isChecked():
                try:
                    self.preview.pop('Time')
                except Exception:
                    pass
                try:
                    self.preview.insert(loc=0, column='DateTime', value=self.dtime)
                except Exception:
                    pass
                try:
                    self.preview = self.preview[self.preview['DateTime'] > start]
                except Exception:
                    pass
                try:
                    self.preview = self.preview[self.preview['DateTime'] < end]
                except Exception:
                    pass
                self.timeHandler(self.preview)

            elif self.date1.isChecked() and self.time2.isChecked():
                try:
                    self.preview.pop('Time')
                except Exception:
                    pass
                try:
                    self.preview.insert(loc=0, column='DateTime', value=self.dtime)
                except Exception:
                    pass
                try:
                    self.preview = self.preview[self.preview['DateTime'] > start]
                except Exception:
                    pass
                try:
                    self.preview = self.preview[self.preview['DateTime'] < end]
                except Exception:
                    pass
                self.timeHandler(self.preview)
                self.preview['Time'] = self.preview['Time'].str.replace(':', ' ')
            elif self.date1.isChecked() and self.time3.isChecked():
                try:
                    self.preview.insert(loc=0, column='DateTime', value=self.dtime)
                except Exception:
                    pass
                try:
                    self.preview = self.preview[self.preview['DateTime'] > start]
                except Exception:
                    pass
                try:
                    self.preview = self.preview[self.preview['DateTime'] < end]
                except Exception:
                    pass
                try:
                    self.preview.insert(loc=0, column='Date', value=self.dtime_date)
                except Exception:
                    pass
                try:
                    self.preview.pop('DateTime')
                except Exception:
                    pass
            elif self.date2.isChecked() and self.time1.isChecked():
                try:
                    self.preview.pop('Time')
                except Exception:
                    pass
                try:
                    self.preview.insert(loc=0, column='DateTime', value=self.dtime)
                except Exception:
                    pass
                try:
                    self.preview = self.preview[self.preview['DateTime'] > start]
                except Exception:
                    pass
                try:
                    self.preview = self.preview[self.preview['DateTime'] < end]
                except Exception:
                    pass
                self.timeHandler(self.preview)
                self.preview['Date'] = self.preview['Date'].str.replace('-', ' ')
            elif self.date2.isChecked() and self.time2.isChecked():
                try:
                    self.preview.pop('Time')
                except Exception:
                    pass
                try:
                    self.preview.insert(loc=0, column='DateTime', value=self.dtime)
                except Exception:
                    pass
                try:
                    self.preview = self.preview[self.preview['DateTime'] > start]
                except Exception:
                    pass
                try:
                    self.preview = self.preview[self.preview['DateTime'] < end]
                except Exception:
                    pass
                self.timeHandler(self.preview)
                self.preview['Date'] = self.preview['Date'].str.replace('-', ' ')
                self.preview['Time'] = self.preview['Time'].str.replace(':', ' ')
            elif self.date2.isChecked() and self.time3.isChecked():
                try:
                    self.preview.insert(loc=0, column='DateTime', value=self.dtime)
                except Exception:
                    pass
                try:
                    self.preview = self.preview[self.preview['DateTime'] > start]
                except Exception:
                    pass
                try:
                    self.preview = self.preview[self.preview['DateTime'] < end]
                except Exception:
                    pass
                try:
                    self.preview.insert(loc=0, column='Date', value=self.dtime_date)
                except Exception:
                    pass
                try:
                    self.preview.pop('DateTime')
                except Exception:
                    pass
                try:
                    self.preview['Date'] = self.preview['Date'].str.replace('-', ' ')
                except Exception:
                    pass
            elif self.date3.isChecked() and self.time1.isChecked():
                try:
                    self.preview.pop('Time')
                except Exception:
                    pass
                try:
                    self.preview.insert(loc=0, column='DateTime', value=self.dtime)
                except Exception:
                    pass
                try:
                    self.preview = self.preview[self.preview['DateTime'] > start]
                except Exception:
                    pass
                try:
                    self.preview = self.preview[self.preview['DateTime'] < end]
                except Exception:
                    pass
                self.timeHandler(self.preview)
                self.preview.pop('Date')
            elif self.date3.isChecked() and self.time2.isChecked():
                try:
                    self.preview.pop('Time')
                except Exception:
                    pass
                try:
                    self.preview.insert(loc=0, column='DateTime', value=self.dtime)
                except Exception:
                    pass
                try:
                    self.preview = self.preview[self.preview['DateTime'] > start]
                except Exception:
                    pass
                try:
                    self.preview = self.preview[self.preview['DateTime'] < end]
                except Exception:
                    pass
                self.timeHandler(self.preview)
                self.preview.pop('Date')
                self.preview['Time'] = self.preview['Time'].str.replace(':', ' ')
            elif self.date3.isChecked() and self.time3.isChecked():
                try:
                    self.preview.insert(loc=0, column='DateTime', value=self.dtime)
                except Exception:
                    pass
                try:
                    self.preview = self.preview[self.preview['DateTime'] > start]
                except Exception:
                    pass
                try:
                    self.preview = self.preview[self.preview['DateTime'] < end]
                except Exception:
                    pass
                try:
                    self.preview.pop('DateTime')
                except Exception:
                    pass
            else:
                pass
            # Plain header
            if self.header1.isChecked():
                if self.comma.isChecked():
                    if self.fillvalue1.isChecked():
                        self.preview.head(20).to_csv(self.output_file, header=True, index=False, na_rep=-32767.0)
                        self.formatPreview_GUI()
                    elif self.fillvalue2.isChecked():
                        self.preview.head(20).to_csv(self.output_file, header=True, index=False, na_rep='')
                        self.formatPreview_GUI()
                    elif self.fillvalue3.isChecked():
                        self.preview = self.preview.fillna(method='ffill')
                        self.preview.head(20).to_csv(self.output_file, header=True, index=False)
                        self.formatPreview_GUI()
                    else:
                        print('File not converted: ' + self.input_file)
                elif self.space.isChecked():
                    if self.fillvalue1.isChecked():
                        self.preview.head(20).to_csv(self.output_file, header=True, index=False, na_rep=-32767.0, sep=' ')
                        self.formatPreview_GUI()
                    elif self.fillvalue2.isChecked():
                        self.preview.head(20).to_csv(self.output_file, header=True, index=False, na_rep='', sep=' ')
                        self.formatPreview_GUI()
                    elif self.fillvalue3.isChecked():
                        self.preview = self.preview.fillna(method='ffill')
                        self.preview.head(20).to_csv(self.output_file, header=True, index=False, sep=' ')
                        self.formatPreview_GUI()
                    else:
                        print('File not converted: ' + self.input_file)
                else:
                    print('File not converted: ' + self.input_file)
            # ICARTT header
            elif self.header2.isChecked():
                self.lib_path = str(os.path.abspath(os.path.dirname(__file__)))
                if self.lib_path == '/opt/local/bin':
                    try:
                        self.lib_path = self.lib_path.replace("bin", "lib")
                    except Exception:
                        pass
                else:
                    try:
                        self.lib_path = str(self.lib_path)+'/lib/'
                    except Exception:
                        pass
                # drop the unit and dimension rows for ICARTT
                self.preview.columns = self.preview.columns.droplevel(1)
                self.preview.columns = self.preview.columns.droplevel(1)
                self.ICARTTHeader(self.preview, self.lib_path)
                with open(self.output_file) as preview:
                    head = str(preview.readlines()[0:75])
                    head = head.replace('\\n', '\n')
                    head = head.replace('[', '')
                    head = head.replace(']', '')
                    head = head.replace("', '", '')
                    head = head.replace("'", '')
                self.outputpreview.setText(head)
            elif self.header3.isChecked():
                # drop the unit and dimension rows for AMES
                self.preview.columns = self.preview.columns.droplevel(1)
                self.preview.columns = self.preview.columns.droplevel(1)
                self.AMESHeader(self.preview)
                with open(self.output_file) as preview:
                    head = str(preview.readlines()[0:75])
                    head = head.replace('\\n', '\n')
                    head = head.replace('[', '')
                    head = head.replace(']', '')
                    head = head.replace("', '", '')
                    head = head.replace("'", '')
                self.outputpreview.setText(head)
        except Exception:
            processing_complete = QMessageBox()
            processing_complete.setWindowTitle("Error")
            processing_complete.setText("There was an error writing your ASCII file. Please try again.")
            x = processing_complete.exec_()
        else:
            pass

    #########################################################################
    # Define function to write data to output file
    #########################################################################
    def writeData(self):

        #####################################################################
        # Get inputs from GUI or CL depending on mode
        #####################################################################
        try:
            self.write = self.asc_new
        except Exception:
            try:
                self.write = self.asc_new_batch
            except Exception:
                self.write = self.asc
################################################################################################
        for columnName,columnData in self.write.items():
                #print(columnName)
                try:
                    self.write[columnName] = columnData.map(lambda x: '%5f' % x)
                except Exception as e:
                    pass
################################################################################################
        # determine which output file to use based on mode
        try:
            output_file = os.path.join(self.outputdirbox.text(), self.outputfilebox.text())
            start = self.start.text()
            end = self.end.text()
            self.date = 'yyyy-mm-dd' if self.date1.isChecked() else 'yyyy mm dd' if self.date2.isChecked() else 'NoDate'
            self.time = 'hh:mm:ss' if self.time1.isChecked() else 'hh mm ss' if self.time2.isChecked() else 'SecOfDay'
            self.fillvalue = -32767 if self.fillvalue1.isChecked() else 'Blank' if self.fillvalue2.isChecked() else 'Replicate'
            self.delimiter = 'comma' if self.comma.isChecked() else 'space'
            self.header = 'Plain' if self.header1.isChecked() else 'ICARTT' if self.header2.isChecked() else 'AMES'
        except Exception as e:
            self._log_exception(e)
            output_file = self.output_file
            start = self.start_time
            end = self.end_time
        try:
            os.remove(str(self.output_file))
        except Exception:
            pass
        # try to get the start and end time from the gui then from the batchfile
        buttonReply = 'No'
        if exists(output_file):
            try:
                buttonReply = QMessageBox.question(self, 'Warning', "Output file already exists. Overwrite?", QMessageBox.Yes | QMessageBox.No)
            except Exception:
                pass
        if buttonReply == QMessageBox.No:
            print('No clicked. Exiting.')
            return
        
        print('Continuing...')
            # gui fields
            
        # Confirm formatting-- set from batchfile or defaults if using CLI
        # print('Date Format: ' + self.date)            
        # print('Time Format: ' + self.time)
        # print('Delimiter Format: ' + self.delimiter)
        # print('FillValue Format: ' + str(self.fillvalue))
        # print('Header Format: ' + self.header)

            # get averaging information from window then batchfile
        self.averaging_window = getattr(self, 'averagingbox', None)
        if self.averaging_window:
            self.averaging_window = self.averaging_window.text()
        else:
            self.averaging_window = self.avg

        if self.averaging_window:
            self.averaging_window = int(self.averaging_window)
            self.write = self.write.rolling(self.averaging_window, min_periods=0).mean().round(decimals=0)
            self.write = self.write.iloc[::self.averaging_window, :]
        #################################################################
        # Date and time combination checks for output file
        #################################################################
        def _process_date_time(replace_time=True, replace_date=True, date_replace=None, time_replace=None):
            """
            Process the DateTime, Date, and Time columns of the dataframe.
            """
            try:
                self.write.pop('Time')
            except KeyError:
                print(f"Column 'Time' does not exist. Columns available: {self.write.columns}")
            except Exception as e:
                self._log_exception(e)

            _insert_column('DateTime', self.dtime)

            _trim_data_frame()

            if replace_time:
                _insert_column('Time', self.dtime_time)
                if time_replace:
                    _replace_column_values('Time', ':', time_replace)

            if replace_date:
                _insert_column('Date', self.dtime_date)
                if date_replace:
                    _replace_column_values('Date', '-', date_replace)

            self.write.pop('DateTime')

        def _insert_column(column_name, value):
            """Insert a column into the dataframe."""
            try:
                self.write.insert(0, column=column_name, value=value)
            except Exception as e:
                self._log_exception(e)

        def _replace_column_values(column_name, old, new):
            """Replace values in a column."""
            try:
                self.write[column_name] = self.write[column_name].str.replace(old, new)
            except Exception as e:
                self._log_exception(e)

        def _trim_data_frame():
            """Trim rows in the dataframe based on a condition."""
            try:
                self.write = self.write[start< self.write['DateTime'] < end]
            except:
                print('Not trimming data frame')

        

        def process_date_time():
            """Map combinations of date and time formats to processing configurations."""
            config_map = {
                ('yyyy-mm-dd', 'hh:mm:ss'): {},
                ('yyyy-mm-dd', 'hh mm ss'): {'time_replace': ' '},
                ('yyyy-mm-dd', 'SecOfDay'): {'replace_time': False},
                ('yyyy mm dd', 'hh:mm:ss'): {'date_replace': ' '},
                ('yyyy mm dd', 'hh mm ss'): {'date_replace': ' ', 'time_replace': ' '},
                ('yyyy mm dd', 'SecOfDay'): {'replace_time': False, 'date_replace': ' '},
                ('NoDate', 'hh:mm:ss'): {'replace_date': False},
                ('NoDate', 'hh mm ss'): {'replace_date': False, 'time_replace': ' '},
                ('NoDate', 'SecOfDay'): {'replace_date': False, 'replace_time': False},
            }

            # Get the config based on `self.date` and `self.time`, or default to an empty dict
            config = config_map.get((self.date, self.time), {})

            # Call `_process_date_time` with the resolved configuration
            _process_date_time(**config) 

        process_date_time() 
        if self.header == 'Plain':
            na_rep = '-32767.0' if self.fillvalue == '-32767' else ''
            if self.fillvalue == 'Replicate':
                self.write = self.write.fillna(method='ffill')
                na_rep = None

            sep = ',' if self.delimiter == 'comma' else ' '
            cellsizes_lines = []
            if self.histo:
                for var in self.cellsize_dict:
                    cellsizes_lines.append(f'{var} Cellsizes: {", ".join(map(str, self.cellsize_dict[var].flatten()))}\n')
                cells_len = len(self.cellsize_dict)

            # Write the Cellsizes information to the file
            with open(output_file, 'w') as f:
                f.writelines(cellsizes_lines)

# Append the DataFrame content to the file
            self.write.to_csv(output_file, mode='a', header=True, index=False, na_rep=na_rep, sep=sep)
            try:
                self.processingSuccess_GUI()
            except Exception as e:
                pass
        # ICARTT header
        elif self.header == 'ICARTT':
            
            self.lib_path = str(os.path.abspath(os.path.dirname(__file__)))
            if self.lib_path == '/opt/local/bin':
                try:
                    self.lib_path = self.lib_path.replace("bin", "lib")
                except Exception as e:
                    print(e)
                    print(traceback.format_exc())
            else:
                try:
                    self.lib_path = str(self.lib_path) + '/lib/'
                except Exception as e:
                    print(e)
                    print(traceback.format_exc())

            # Drop levels until there is only one level left in the columns
            while isinstance(self.write.columns, pd.MultiIndex):
                try:
                    self.write.columns = self.write.columns.droplevel(1)
                except IndexError:
                    break

            # Rename the time var to Time_Start
            self.write = self.write.rename(columns={'Time': 'Time_Start', 'DateTime': 'Time_Start'})
            # Convert columns to float
            for column in self.write.columns:
                try:
                    self.write[column] = self.write[column].astype(float)
                except Exception:
                    if column == 'Time_Start' or column == 'Date':
                        pass
                    else:
                        print(f'Could not convert {column} to float')
                        pass
            self.write = self.write.replace(np.nan, -99999.0)
            self.write.to_csv(output_file, header=True, index=False)
            self.varNumber = str(len(self.write.columns) - 1)
            try:
                self.data_date = str(self.dtime_sep[0].iloc[1]).replace('-', ', ')
                os.system(f'cp {self.lib_path}/header1.txt ./header1.tmp')
                os.system("ex -s -c '5i' -c x ./header1.tmp")
                os.system(f'cp {self.lib_path}/header2.txt ./header2.tmp')
                self.today = datetime.today().strftime('%Y, %m, %d')

                with open('./header1.tmp', 'r+') as f:
                    lines = f.readlines()
                    for i, line in enumerate(lines):
                        if line.startswith('RAF instruments on'):
                            lines[i] = f'{line.strip()} {self.platform}\n'
                        if line.startswith('<PROJECT MANAGER>'):
                            lines[i] = f'{self.project_manager}\n'
                        if line.startswith('<PROJECT>'):
                            lines[i] = f'{self.project_name}\n'
                        if line.startswith('<YYYY, MM, DD,>'):
                            lines[i] = f'{self.data_date}, {self.today}\n'
                        if line.startswith('<varNumber>'):
                            lines[i] = f'{self.varNumber}\n'
                        if line.startswith('<1.0>'):
                            lines[i] = '1.0,' * int(self.varNumber)
                            lines[i] = lines[i].rstrip(',') + '\n'
                        if line.startswith('<-99999.0>'):
                            lines[i] = '-99999.0,' * int(self.varNumber)
                            lines[i] = lines[i].rstrip(',') + '\n'
                    f.seek(0)
                    f.writelines(lines)

                with open('./header2.tmp', 'r+') as f:
                    lines = f.readlines()
                    if self.histo:
                        for var in self.cellsize_dict:
                            lines.insert(3, f'{var} Cellsizes: {", ".join(map(str, self.cellsize_dict[var].flatten()))}\n')
                        cells_len = len(self.cellsize_dict)
                    for i, line in enumerate(lines):
                        if line.startswith('18'):
                            lines[i] =str(cells_len+18) + '\n'
                        if line.startswith('<PLATFORM>'):
                            lines[i] = f'PLATFORM: NSF/NCAR {self.platform} {self.tail_number}\n'
                        if line.startswith('REVISION: RA'):
                            lines[i] = line.replace('RA', self.version)
                    f.seek(0)
                    f.writelines(lines)

                self.columns = pd.DataFrame(self.write.columns.values.tolist())
                self.fileheader = self.fileheader.loc[self.fileheader[0].isin(self.columns[0])]
                self.fileheader.to_csv('./header1.tmp', mode='a', header=False, index=False)
                os.system('cat ./header1.tmp ./header2.tmp > ./header.tmp')

                with open('./header.tmp', 'r+') as f:
                    lines = f.readlines()
                    count = f'{len(lines) + 1}, 1001, V02_2016'
                    for i, line in enumerate(lines):
                        if line.startswith('<ROWCOUNT>'):
                            lines[i] = f'{count}\n'
                        f.seek(0)
                        f.writelines(lines)

                self.icartt_filename_date = self.data_date.replace(', ', '')
                self.icartt_filename = f'{self.project_name}-CORE_{self.platform}_{self.icartt_filename_date}_{self.version}.ict'
                print(f'Overwriting Output Filename, since ICARTT file has strict format: {self.icartt_filename}')
                os.system(f'mv {output_file} {output_file}.tmp')
                os.system(f'cat ./header.tmp {output_file}.tmp >> {output_file}')
                os.system(f'mv {output_file} {os.path.abspath(os.path.dirname(output_file))}/{self.icartt_filename}')
                os.system(f'rm header.tmp header1.tmp header2.tmp {output_file}.tmp')
            except Exception:
                print(traceback.format_exc())
                print('ICARTT header was not created or appended to output file')

            try:
                self.processingSuccess_GUI()
            except Exception:
                print('Processing complete')
        # AMES header
        elif self.header == 'AMES':
            try:
                # drop the unit and dimension rows for AMES
                self.write.columns = self.write.columns.droplevel(1)
                self.write.columns = self.write.columns.droplevel(1)
                self.AMESHeader(self.write)
            except Exception:
                print('AMES header was not created or appended to output file.')
            try:
                self.processingSuccess_GUI()
                self.deselectAll_GUI()
            except Exception as e:
                print(e)
        # try:
        #     processing_complete = QMessageBox()
        #     processing_complete.setWindowTitle("Error")
        #     processing_complete.setText("There was an error writing your ASCII file. Please try again.")
        #     x = processing_complete.exec_()
        # except Exception as e:
        #     print(e)
        #     print('Data was not written. Please try again.')
    


#############################################################################
# nc2asc CL Class
#############################################################################
class nc2asc_CL():
    def __init__(self):
        self.guiMode = False
        self.histo = False
        self.timeHandler = gui.timeHandler
        self.input_file = False
        self.output_file = False
        self.inputbatch_file = False
        self.rate = False
        self.vars = False
        self.variables_extract_batch=[]
        self.cellsize_dict = {}
        self.version = 'RA' ##Defaults to field data unless overridden
    #inherit self._log_exception from nc2asc_GUI
        self.fillvalue = '-32767'
        self.delimiter = 'comma'
        self.date = 'yyyy-mm-dd'
        self.time = 'hh:mm:ss'
        self.header = 'Plain'
    def _log_exception(self, e):
        print(e)
        print(traceback.format_exc())

    def parse_args(self):
        # set up argument parsing
        parser = argparse.ArgumentParser(description='Provide (Optional) (-i) Input File (Optional) (-o) Output File and (-b) Batch File')
        # define input file(s) to process
        parser.add_argument('-b', type=str, help='Batch file')
        parser.add_argument('-i', type=str, help='(Optional) Input file to convert' + 'e.g. /scr/raf_data/<PROJECT>/PROJECTrf01.nc')
        parser.add_argument('-o', type=str, help='(Optional) Output file')
        parser.add_argument('-mixed_rate', action='store_true')
        parser.add_argument('-v', type=str, nargs='+', help='(Optional) Variables to convert with HRT or SRT conversion. Defaults to all.')
        args = parser.parse_args()
        return(args)
    
    def store_File(self,ln):
        filename = []
        filename = str(ln[2:])
        filename = filename.replace('=', '')
        filename = filename.replace("'", '')
        filename = filename.replace('\n', '')
        print(f'Using filename from the batch file: '+filename)
        return filename
    
    def process_batch_file(self, inputbatch_file):
        """Processes a batch file to extract settings and variables."""
        action_map = {
            'if=': lambda ln: self._handle_file(ln, 'input_file', 'Input'),
            'of=': lambda ln: self._handle_file(ln, 'output_file', 'Output'),
            'hd=': lambda ln: self._handle_directive(ln, 'header', self._header_map()),
            'dt=': lambda ln: self._handle_directive(ln, 'date', self._date_map()),
            'tm=': lambda ln: self._handle_directive(ln, 'time', self._time_map()),
            'sp=': lambda ln: self._handle_directive(ln, 'delimiter', self._delimiter_map()),
            'fv=': lambda ln: self._handle_directive(ln, 'fillvalue', self._fillvalue_map()),
            'version=': lambda ln: setattr(self, 'version', ln.replace('version=', '').strip()),
            'ti=': lambda ln: setattr(self, 'ti', ln[3:].strip()),
            'avg=': lambda ln: setattr(self, 'avg', self._format_avg(ln[4:])),
            'Vars=': lambda ln: self._add_variable(ln),
        }
        set_vars = {
            'hd=': self.header,
            'dt=': self.date,
            'tm=': self.time,
            'sp=': self.delimiter,
            'fv=': self.fillvalue,
        }
        
        with open(inputbatch_file, 'r') as fil:
            print('****Reading Batch File****')
            for ln in fil:
                ln = ln.strip()
                for key, action in action_map.items():
                    if ln.startswith(key):
                        action(ln)
                        break
            print('Batch file processing complete.')
        
    def _header_map(self):
        return {
            'hd=Plain': ('header1', 'Plain'),
            'hd=ICARTT': ('header2', 'ICARTT'),
            'hd=AMES': ('header3', 'AMES'),
        }

    def _date_map(self):
        return {
            'dt=yyyy-mm-dd': ('date1', 'yyyy-mm-dd'),
            'dt=yyyy mm dd': ('date2', 'yyyy mm dd'),
            'dt=NoDate': ('date3', 'NoDate'),
        }

    def _time_map(self):
        return {
            'tm=hh:mm:ss': ('time1', 'hh:mm:ss'),
            'tm=hh mm ss': ('time2', 'hh mm ss'),
            'tm=SecOfDay': ('time3', 'SecOfDay'),
        }

    def _delimiter_map(self):
        return {
            'sp=comma': ('comma', 'comma'),
            'sp=space': ('space', 'space'),
        }

    def _fillvalue_map(self):
        return {
            'fv=-32767': ('fillvalue1', '-32767'),
            'fv=blank': ('fillvalue2', 'blank'),
            'fv=replicate': ('fillvalue3', 'replicate'),
        }

    def _handle_file(self, line, attr_name, file_type):
        """Prompt user to confirm file selection from batch file or use command line input."""
        batch_file_value = self._parse_file_path(line)
        current_value = getattr(self, attr_name, None)

        if not current_value:
            print(f'No {file_type} file provided.')
            setattr(self, attr_name, batch_file_value)
        else:
            choice = input(
                f"Would you like to use the {file_type.lower()} file from the batch file? (y/Y to confirm, any other key to keep current): "
            )
            if choice.lower() == 'y':
                setattr(self, attr_name, batch_file_value)
            else:
                print(f"Using {file_type.lower()} file from command line: {current_value}")

    def _parse_file_path(self, line):
        """Extract file path from a batch file line."""
        return line.split('=')[1].strip()

    def _handle_directive(self, line, attr_name, directive_map):
        """Set an attribute and toggle GUI checkbox based on a line and a directive map."""
        if line in directive_map:
            gui_attr, value = directive_map[line]
            try:
                getattr(self, gui_attr).setChecked(True)
            except AttributeError:
                setattr(self, attr_name, value)

    def _add_variable(self, line):
        """Extract and add variables from a batch file line."""
        variable = line.replace('Vars=', '').replace("'", "").replace('[', '').replace(']', '').strip()
        if variable not in self.variables_extract_batch:
            self.variables_extract_batch.append(variable)

    def _format_avg(self, avg):
        """Format the averaging value from the batch file."""
        return avg.translate({ord(c): None for c in "[]='g"}).strip()[:-1]
    
    #######################################################################
    # Define processing function
    #######################################################################
    def processData(self, args):
        self.input_file = args.i if args.i else False
        self.output_file = args.o if args.o else False
        self.inputbatch_file = args.b if args.b else False
        try:
            self.rate = args.mixed_rate
        except Exception as e:
            self._log_exception(e)
            self.rate = False
        try:
            self.vars = args.v
        except Exception as e:
            self._log_exception(e)
        if self.input_file:
            print('INPUT FILE:' + self.input_file)
            # read in the input file
        if self.output_file:
            print('OUTPUT_FILE:' + self.output_file)
            
        if self.inputbatch_file:
            gui.process_batch_file(self,self.inputbatch_file)
        #Make sure evyerhing is set to defaults even if batchfile is provided.
        #Use ICARTT header by default
        else:
            try:
                self.header2.setChecked(True)
            except:
                print("Using default header format: ICARTT")
                self.header = 'ICARTT'
            #Use yyyy-mm-dd by default
            try:
                self.date1.setChecked(True)
            except Exception:
                print("Using default date format: yyyy-mm-dd")
                self.date = 'yyyy-mm-dd'
            #Use hh:mm:ss by default
            try:
                self.time1.setChecked(True)
            except Exception:
                print("Using default time format: hh:mm:ss")
                self.time = 'hh:mm:ss'
            try:
                self.comma.setChecked(True)
            except Exception:
                print("Using default delimiter: comma")
                self.delimiter = 'comma'
            try:
                self.fillvalue2.setChecked(True)
            except Exception:
                print("Using default fill value: blank")
                self.fillvalue = 'blank'
        self.variables_extract_batch =[]
        self.asc_new_batch = pd.DataFrame()
        self.version = 'RA'

        # set default time and averaging: no averaging or time trimming
        self.ti = 'X,X'
        self.avg = ''
            
        nc = xr.open_dataset(self.input_file,decode_times=False)
        # keep mixed_rate bool arg, to enter this as opposed to the full conversion.
        if args.mixed_rate:

            # create placeholder dictionaries for dimensions and rate deltas

            variable_output = {}
            rate_delta_dict = {}
            asc = pd.DataFrame()
            temp_df = pd.DataFrame()
            variable_dimension_dict = {}

            # check to see if variables were included on command line
            if args.v is None:
                vars = nc.variables
            else:
                if 'Time' in args.v:
                    vars = args.v
                else:
                    args.v.insert(0, 'Time')
                    vars = args.v
            # iterate over vars
            for i in vars:

                # extract rates and append to dictionary
                dim = str(nc[i].dims).replace("('Time',)", str(1)).replace("('Time', 'sps", '').replace("')", '')
                variable_dimension_dict[i] = dim
                # find maximum rate
                value_list = variable_dimension_dict.values()

                # determine least common multiple for maximum rate, so no vals are lost
                lcm = list(value_list)[0]
                for i in range(1, len(value_list)):
                    lcm = int(lcm) * int(list(value_list)[i]) // math.gcd(int(lcm), int(list(value_list)[i]))

            # find the rate delta for each variable based on var dim and lcm dim
            for key, value in variable_dimension_dict.items():
                rate_delta_dict[key] = int(lcm) // int(value)
                print(str(key) + ' Rate: ' + str(value))
            # build the mixed rate dataframe
            for i in vars:
                variable_output = nc[i][:]
                temp_df = pd.DataFrame(variable_output.flatten())
                n = rate_delta_dict[i]
                mixed_rate_index = pd.RangeIndex(len(temp_df)*(n))
                reshape_asc = pd.DataFrame(np.nan, index=mixed_rate_index, columns=temp_df.columns)
                ids = np.arange(len(temp_df))*(n)
                reshape_asc.loc[ids] = temp_df.values
                asc = pd.concat([asc, reshape_asc], axis=1)
            asc.columns = [vars]
            # interpolate time in milliseconds for 100 Hz data if its there
            asc['Time'] = asc['Time'].interpolate()
            # forward fill mixed rate data
            asc = asc.ffill()
            # round to 5 significant digits
            asc = round(asc, 5)
            # keep trailing zeros for milliesconds in Time column
            time = np.array(asc['Time'])
            temp_time = []
            for i in time:
                i = "{:.3f}".format(float(i))
                temp_time.append(i)
            time = pd.DataFrame(temp_time, columns=['Time'])
            asc['Time'] = time['Time']
            # write to output file
            asc.to_csv(args.o, index=False)

        else:
            # create an empty pandas series to hold variables
            self.variables_extract = pd.Series(dtype='str')
            # create empty dicts
            self.asc = {}
            self.units = {}
            self.long_name = {}
            self.variables = {}
            self.fileheader = {}
            self.project_manager = 'Patrick Veres, Pavel Romashkin'
            try:
                self.tail_number = nc.attrs['Platform']
            except KeyError:
                self.tail_number = nc.attrs['platform']
            if self.tail_number == 'N677F':
                self.platform = 'GV'
            elif self.tail_number == 'N130AR':
                self.platform = 'C130'
            self.project_name = nc.attrs['project']
            self.today = str(datetime.today().strftime('%Y, %m, %d'))
            self.today = self.today.replace('-', ', ')
            
            
            gui.parse_vars(self,nc)


            # concatenate
            print('****Concatenating Variables****')
            
            self.asc = pd.concat(self.asc, axis=1, ignore_index=False)
            self.asc.columns = self.asc.columns.droplevel(0) # Drop the first variable level that does not have bin numbers
            while isinstance(self.asc.columns, pd.MultiIndex):
                try:
                    self.asc.columns = self.asc.columns.droplevel(1)
                except IndexError:
                    break
            
            # create an object to store the netCDF variable time
            self.dtime = xr.coding.times.decode_cf_datetime(nc['Time'], nc['Time'].attrs['units'])
            self.dtime = pd.Series(self.dtime).astype(str)
            self.dtime_sep = self.dtime.str.split(' ', expand=True)
            # create separate date and time series for combination in previewData and writeData
            self.dtime_date = self.dtime_sep[0]
            self.dtime_time = self.dtime_sep[1]
            # concatenate the units, long_name, variables, and header
            self.units = pd.concat(self.units, axis=0, ignore_index=True)
            self.long_name = pd.concat(self.long_name, axis=0, ignore_index=True)
            self.variables = pd.concat(self.variables, axis=0, ignore_index=True)
            self.fileheader = pd.concat([self.variables, self.units, self.long_name], axis=1, ignore_index=True)
            # subset the start and end time from the dtime object by position
            self.start_time = self.dtime.iloc[0]
            self.end_time = self.dtime.iloc[-1]
            self.dtime = nc['Time']
            

            if not self.variables_extract_batch:
                print('Using all variables')
                self.variables_extract_batch = list(nc.variables)  
                self.asc_new_batch = self.asc

            else:
                for x, var in enumerate(self.variables_extract_batch):
                    if var not in self.asc.columns:
                        #Remove var from list if it is not in the netCDF file
                        
                        print('***WARNING***Var '+str(var)+' not in netCDF file!!! Continuing with conversion****')
                self.variables_extract_batch = [var for var in self.variables_extract_batch if var in self.asc.columns]
                self.asc_new_batch = self.asc[self.variables_extract_batch]
            try:
                for i in self.variables_extract_batch:
                    if i not in nc.variables:
                        print('***WARNING****Var '+str(i)+' not in netCDF file!!! Continuing with conversion****')
                    else:
                        pass
            except Exception as e:
                self._log_exception(e)
            try:
                gui.writeData(self)
                print('****Write Data Process Complete****')
            except Exception as e:
                self._log_exception(e)
            return self.asc, self.input_file, self.output_file, self.dtime_date, self.dtime_time, self.dtime


#############################################################################
# Define main function to determine mode
# Program can execute to render GUI or can process via command line
#############################################################################
def main():

    if len(sys.argv) > 1:
        try:
            cl = nc2asc_CL()
        except Exception as e:
            gui._log_exception(e)
        try:
            args = cl.parse_args()
        except Exception as e:
            gui._log_exception(e)
        try:
            cl.processData(args)
        except Exception as e:
            gui._log_exception(e+ ': Error processing data')
    else:
        app = QtWidgets.QApplication(sys.argv)
        app.setStyle('Windows')
        ex = gui()
        ex.show()
        sys.exit(app.exec_())


#############################################################################
# Call main function
#############################################################################
if __name__ == "__main__":

    main()
