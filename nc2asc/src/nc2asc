#! /usr/bin/env python3
#######################################################################
# Python 3 based netCDF to ASCII converter with GUI
#
# Generates plain text, ICARTT or AMES header files with multiple
# delimiter, fill value, date, and time formats.
#
# Program consists of two classes 1) "gui" and 2) "nc2asc_CL"
# Function names include "_GUI" if the function is only used within
# the GUI.
#
# Update June 2022 (TMT):Main function determines whether the mode
# is GUI or command line based on the number of arguments included.
#
# Copyright University Corporation for Atmospheric Research (2021-2022)
#######################################################################

import os
from os.path import exists
import sys
import argparse
import pandas as pd
import numpy as np
import math
from datetime import datetime
from warnings import simplefilter, filterwarnings
from PyQt5 import QtGui, QtCore, QtWidgets
from PyQt5.QtCore import Qt
import xarray as xr
import traceback
# Add the installation directory to the Python path
nc2asc_lib = os.path.join(os.path.dirname(sys.argv[0]), '..', 'lib', 'nc2asc')
if os.path.exists(nc2asc_lib):
    sys.path.append(nc2asc_lib)

# Now import the modules directly (without lib prefix)
from write_data import formatData, writeData, ICARTTHeader, AMESHeader, PLAINHeader
from process_nc import process_date_time
from read_batch import process_batch_file, readBatchFile, saveBatchFile_GUI
from PyQt5.QtWidgets import QTextBrowser, QGroupBox, QGridLayout, QWidget, QHBoxLayout, QFrame, QScrollBar, QToolBar, QMessageBox, QFileDialog, QTableWidgetItem, QVBoxLayout, QMenu, QMenuBar, QMainWindow, QAction, qApp, QApplication

simplefilter(action="ignore", category=pd.errors.PerformanceWarning)
filterwarnings(action='ignore', category=DeprecationWarning, message='`np.bool` is a deprecated alias')
class gui(QMainWindow):

    def __init__(self):

        super(gui, self).__init__()

        self.initUI()

    #########################################################################
    # Define layout of gui
    # Set up the fields, table, buttons, and menu
    # nc2asc uses a combination of absolute positioning and QGridLayout
    # Components of QGridLayout are added to layout before absolute position
    #########################################################################
    def initUI(self):

        # bold font to help with organization of processing options
        myFont = QtGui.QFont()
        myFont.setBold(True)
        self.histo = False
        self.cellsize_dict = {}
        self.variables_extract_batch = []

        #####################################################################
        # QGridLayout: Variable table and selection / deselection options
        #####################################################################
        # button to select all variables
        self.varbtn = QtWidgets.QPushButton('Select All', self)
        self.varbtn.move(600, 30)
        self.varbtn.clicked.connect(self.loadVars_GUI)
        self.varbtn.clicked.connect(self.selectAll_GUI)
        # button to de-select all variables
        self.varbtn2 = QtWidgets.QPushButton('Clear All', self)
        self.varbtn2.move(700, 30)
        self.varbtn2.clicked.connect(self.loadVars_GUI)
        self.varbtn2.clicked.connect(self.deselectAll_GUI)
        # button to remove current variable
        self.deselectvar = QtWidgets.QPushButton('Remove Var', self)
        self.deselectvar.move(800, 30)
        self.deselectvar.clicked.connect(self.deselectVar_GUI)
        # variable table and buttons with labels
        varlabel = QtWidgets.QLabel(self)
        varlabel.setText('Click Vars:')
        varlabel.move(500, 30)
        varlabel.setFont(myFont)
        self.var = QtWidgets.QTableWidget(self)
        self.var.setColumnCount(3)
        header = self.var.horizontalHeader()
        header.setSectionResizeMode(0, QtWidgets.QHeaderView.ResizeToContents)
        self.var.setColumnWidth(2, 100)
        header.setSectionResizeMode(2, QtWidgets.QHeaderView.Stretch)
        self.var.setRowCount(15)
        self.var.move(500, 60)
        self.var.resize(400, 430)
        self.var.setHorizontalHeaderLabels(['Var', 'Units', 'Long Name'])
        self.var.clicked.connect(self.selectVars_GUI)
        self.guiMode = True
        self.version = 'RA'

        #####################################################################
        # QGridLayout: Output preview options
        #####################################################################
        # output preview label
        outputpreviewlabel = QtWidgets.QLabel(self)
        outputpreviewlabel.move(20, 470)
        outputpreviewlabel.setText('Preview:')
        outputpreviewlabel.setFont(myFont)
        # output preview field with horizontal scroll bar
        self.outputpreview = QtWidgets.QTextEdit(self)
        self.outputpreview.move(20, 500)
        self.outputpreview.resize(880, 150)
        self.outputpreview.setLineWrapMode(QtWidgets.QTextEdit.NoWrap)

        # process button calls writeData function
        self.processbtn = QtWidgets.QPushButton('Convert File', self)
        self.processbtn.resize(self.processbtn.sizeHint())
        self.processbtn.move(20, 670)
        self.processbtn.clicked.connect(self.writeData)

        #####################################################################
        # Create a grid layout that can be populated with widgets
        #####################################################################

        grid = QGridLayout()
        grid.setSpacing(10)
        # populate the grid layout with the variable table
        grid.addWidget(self.var, 0, 5, 6, 5)
        # populate the grid layout with the output preview field
        grid.addWidget(self.outputpreview, 7, 0, 2, 10)
        # populate the grid layout with buttons for var selection
        grid.addWidget(self.varbtn, 0, 10)
        grid.addWidget(self.varbtn2, 1, 10)
        grid.addWidget(self.deselectvar, 2, 10)
        # populate the grid layout with the processing button
        grid.addWidget(self.processbtn, 11, 0)
        wid = QtWidgets.QWidget(self)
        self.setCentralWidget(wid)
        wid.setLayout(grid)

        #####################################################################
        # Input file and output dir / file fields
        #####################################################################
        # define input file box and label
        self.inputfilebox = QtWidgets.QLineEdit(self)
        self.inputfilebox.move(140, 40)
        self.inputfilebox.resize(350, 20)
        self.inputlabel = QtWidgets.QLabel(self)
        self.inputlabel.setText('Input File')
        self.inputlabel.move(75, 40)
        # define output dir and file
        # output dir
        self.outputdirlabel = QtWidgets.QLabel(self)
        self.outputdirlabel.setText('Output Directory')
        self.outputdirlabel.move(30, 70)
        self.outputdirbox = QtWidgets.QLineEdit(self)
        self.outputdirbox.move(140, 70)
        self.outputdirbox.resize(350, 20)
        # output file
        self.outputlabel = QtWidgets.QLabel(self)
        self.outputlabel.setText('Output Filename:')
        self.outputlabel.move(30, 100)
        self.outputfilebox = QtWidgets.QLineEdit(self)
        self.outputfilebox.move(140, 100)
        self.outputfilebox.resize(350, 20)

        #####################################################################
        # Start time, end time, and averaging options
        #####################################################################
        # fields for start and end time
        timeselectionlabel = QtWidgets.QLabel(self)
        timeselectionlabel.setText('Time Options:')
        timeselectionlabel.move(20, 140)
        startlab = QtWidgets.QLabel(self)
        startlab.setText('Start:')
        endlab = QtWidgets.QLabel(self)
        endlab.setText('End:')
        startlab.move(100, 160)
        endlab.move(100, 180)
        self.start = QtWidgets.QLineEdit(self)
        self.end = QtWidgets.QLineEdit(self)
        self.start.move(140, 165)
        self.start.resize(140, 20)
        self.end.move(140, 185)
        self.end.resize(140, 20)
        # averaging label and box
        averaginglabel = QtWidgets.QLabel(self)
        averaginglabel.setText('Averaging (s):')
        averaginglabel.move(100, 200)
        averagingnote = QtWidgets.QLabel(self)
        averagingnote.move(280, 200)
        averagingnote.resize(300, 20)
        self.averagingbox = QtWidgets.QLineEdit(self)
        self.averagingbox.move(220, 205)
        self.averagingbox.resize(60, 20)
        # button to update preview based on time options
        self.outputpreviewbutton = QtWidgets.QPushButton('Update Preview', self)
        self.outputpreviewbutton.move(300, 200)
        self.outputpreviewbutton.clicked.connect(self.selectVars_GUI)

        #####################################################################
        # Processing options section
        #####################################################################
        processinglabel = QtWidgets.QLabel(self)
        processinglabel.setText('Output Options:')
        processinglabel.move(20, 240)
        processinglabel.resize(100, 20)
        processinglabel.setFont(myFont)

        #####################################################################
        # Date format options
        #####################################################################
        # radio buttons for date
        dateformatlabel = QtWidgets.QLabel(self)
        dateformatlabel.setText('Date Format:')
        dateformatlabel.move(20, 260)
        dateformatlabel.setFont(myFont)
        self.date1 = QtWidgets.QRadioButton(self)
        self.date1.setText('yyyy-mm-dd')
        self.date1.move(20, 280)
        self.date2 = QtWidgets.QRadioButton(self)
        self.date2.setText('yyyy mm dd')
        self.date2.move(20, 300)
        self.date3 = QtWidgets.QRadioButton(self)
        self.date3.setText('NoDate')
        self.date3.move(20, 320)
        dategroup = QtWidgets.QButtonGroup(self)
        dategroup.addButton(self.date1)
        dategroup.addButton(self.date2)
        dategroup.addButton(self.date3)
        # have the default be date 1 but update the preview when any are clicked
        self.date1.setChecked(True)
        self.date1.clicked.connect(self.selectVars_GUI)
        self.date2.clicked.connect(self.selectVars_GUI)
        self.date3.clicked.connect(self.selectVars_GUI)

        #####################################################################
        # Time format options
        #####################################################################
        # radio buttons for time
        timeformatlabel = QtWidgets.QLabel(self)
        timeformatlabel.setText('Time Format:')
        timeformatlabel.move(200, 260)
        timeformatlabel.setFont(myFont)
        self.time1 = QtWidgets.QRadioButton(self)
        self.time1.setText('hh:mm:ss')
        self.time1.move(200, 280)
        self.time2 = QtWidgets.QRadioButton(self)
        self.time2.setText('hh mm ss')
        self.time2.move(200, 300)
        self.time3 = QtWidgets.QRadioButton(self)
        self.time3.setText('SecOfDay')
        self.time3.move(200, 320)
        timegroup = QtWidgets.QButtonGroup(self)
        timegroup.addButton(self.time1)
        timegroup.addButton(self.time2)
        timegroup.addButton(self.time3)
        # have default be time 1 but update the preview when any are clicked
        self.time1.setChecked(True)
        self.time1.clicked.connect(self.selectVars_GUI)
        self.time2.clicked.connect(self.selectVars_GUI)
        self.time3.clicked.connect(self.selectVars_GUI)

        #####################################################################
        # Delimiter format options
        #####################################################################
        # radio buttons for the delimiter
        delimiterlabel = QtWidgets.QLabel(self)
        delimiterlabel.setText('Delimiter:')
        delimiterlabel.move(380, 260)
        delimiterlabel.setFont(myFont)
        self.comma = QtWidgets.QRadioButton(self)
        self.comma.setText('Comma')
        self.comma.move(380, 280)
        self.space = QtWidgets.QRadioButton(self)
        self.space.setText('Space')
        self.space.move(380, 300)
        delimitergroup = QtWidgets.QButtonGroup(self)
        delimitergroup.addButton(self.comma)
        delimitergroup.addButton(self.space)
        # have default be comma delimited but update the preview when any are clicked
        self.comma.setChecked(True)
        self.comma.clicked.connect(self.selectVars_GUI)
        self.space.clicked.connect(self.selectVars_GUI)

        #####################################################################
        # Fill value format options
        ####################################################################
        # radio buttons for the fill value
        fillvaluelabel = QtWidgets.QLabel(self)
        fillvaluelabel.setText('Fill Value:')
        fillvaluelabel.move(20, 360)
        fillvaluelabel.setFont(myFont)
        self.fillvalue1 = QtWidgets.QRadioButton(self)
        self.fillvalue1.setText('-32767.0')
        self.fillvalue1.move(20, 380)
        self.fillvalue2 = QtWidgets.QRadioButton(self)
        self.fillvalue2.setText('Blank')
        self.fillvalue2.move(20, 400)
        self.fillvalue3 = QtWidgets.QRadioButton(self)
        self.fillvalue3.setText('Replicate')
        self.fillvalue3.move(20, 420)
        fillvaluegroup = QtWidgets.QButtonGroup(self)
        fillvaluegroup.addButton(self.fillvalue1)
        fillvaluegroup.addButton(self.fillvalue2)
        fillvaluegroup.addButton(self.fillvalue3)
        # have default be fill value 1 but update the preview when any are clicked
        self.fillvalue1.setChecked(True)
        self.fillvalue1.clicked.connect(self.selectVars_GUI)
        self.fillvalue2.clicked.connect(self.selectVars_GUI)
        self.fillvalue3.clicked.connect(self.selectVars_GUI)

        #####################################################################
        # Header format options
        #####################################################################
        # radio buttons for header
        headerformatlabel = QtWidgets.QLabel(self)
        headerformatlabel.setText('Header:')
        headerformatlabel.move(200, 360)
        headerformatlabel.setFont(myFont)
        self.header1 = QtWidgets.QRadioButton(self)
        self.header1.setText('Plain')
        self.header1.move(200, 380)
        self.header2 = QtWidgets.QRadioButton(self)
        self.header2.setText('ICARTT')
        self.header2.move(200, 400)
        self.header3 = QtWidgets.QRadioButton(self)
        self.header3.setText('AMES DEF')
        self.header3.move(200, 420)
        headergroup = QtWidgets.QButtonGroup(self)
        headergroup.addButton(self.header1)
        headergroup.addButton(self.header2)
        headergroup.addButton(self.header3)
        # have the default be header 1 (plain) but update the preview when any are clicked
        self.header1.setChecked(True)
        self.header2.clicked.connect(self.ICARTT_AMES_toggle_GUI)
        self.header1.clicked.connect(self.selectVars_GUI)
        self.header2.clicked.connect(self.selectVars_GUI)
        self.header3.clicked.connect(self.ICARTT_AMES_toggle_GUI)
        self.header3.clicked.connect(self.selectVars_GUI)
        self.header2.clicked.connect(self.ICARTTfilename)

        #####################################################################
        # Menu options
        #####################################################################
        mainMenu = self.menuBar()
        fileMenu = mainMenu.addMenu('File')
        helpMenu = mainMenu.addMenu('Help')
        importFile = QAction('Open NetCDF File', self)
        saveBatchFile = QAction('Save Batch File', self)
        readBatchFile = QAction('Read Batch File', self)
        exit = QAction('Exit', self)
        readme = QAction('nc2asc GitHub readme', self)
        fileMenu.addAction(importFile)
        fileMenu.addAction(saveBatchFile)
        fileMenu.addAction(readBatchFile)
        fileMenu.addAction(exit)
        # connect the menu option File > Import NetCDF File to the data functions
        importFile.triggered.connect(self.loadData_GUI)
        importFile.triggered.connect(self.formatData)
        importFile.triggered.connect(self.loadVars_GUI)
        # connect the menu option File > Read Batch file to the function
        readBatchFile.triggered.connect(self.readBatchFile)
        # connect the exit menu option to the close function
        exit.triggered.connect(self.close)
        # connect the save batch file menu option to the function
        saveBatchFile.triggered.connect(self.saveBatchFile_GUI)

        # help launches readme
        helpMenu.addAction(readme)
        readme.triggered.connect(self.openhelp)

        #####################################################################
        # General setup options
        #####################################################################
        # changing the background color to gray
        self.setGeometry(100, 100, 1080, 720)
        self.setWindowTitle('NCAR/EOL RAF Aircraft NetCDF to ASCII File Converter')
        p = self.palette()
        p.setColor(self.backgroundRole(), Qt.white)
        self.setPalette(p)
        self.show()
#############################################################################
# End UI Setup ##############################################################
#############################################################################
    def _log_exception(self, exception):
            """Log exception with traceback."""
            print(exception)
            print(traceback.format_exc())
    def openhelp(self):
        url = QtCore.QUrl('https://github.com/NCAR/aircraft_nc_utils/blob/master/nc2asc/README.md')
        if not QtGui.QDesktopServices.openUrl(url):
            QtGui.QMessageBox.warning(self, 'readme', 'Could not open url')

    #########################################################################
    # Function definitions for batch file saving and reading
    #########################################################################

    # Define function to save a batch file "batchfile" from within GUI



    # Define function to read batch file and render in GUI or use in command line processing mode


#######################################################################
# Function definitions for data loading, formatting, and processing
#######################################################################
    # Define function to load an input netCDF data file into the GUI
    def loadData_GUI(self):

        try:
            # pop up box to select the input file for processing
            self.input_file, _ = QFileDialog.getOpenFileName(self, "Select a File to Convert", "/scr/raf_data", "filter = nc(*.nc)")
            self.inputfilebox.setText(str(self.input_file))
            # use the path to the input file to pre-populate the output dir and filename
            self.head, self.tail = os.path.split(self.input_file)
            # populate the output directory text from the input directory
            self.outputdirbox.setText(str(self.head + '/'))
            # populate the output file text from the input filename with .txt extension
            self.tail = os.path.splitext(self.tail)[0] + '.txt'
            self.outputfilebox.setText(str(self.tail))
        except Exception:
            # if there is an error loading the NetCDF file, notify the user in a popup
            no_process = QMessageBox()
            no_process.setWindowTitle("Error")
            no_process.setText("Cannot Process!")
            x = no_process.exec_()
            
    def parse_vars(self,nc):
        for i in nc.variables:
            # handle only time dimension variables
            dims = str(nc[i].dims)
            if dims == "('Time',)":
                output = nc[i].values
                # append self.asc with vars in file
                self.asc[i] = pd.DataFrame(output,columns=[i])   
                # append self.units with netcdf attribute units
                try:
                    units = nc[i].units
                    self.units[i] = pd.Series([units])
                except AttributeError:
                    self.units[i] = pd.Series([''])
                # append self.long_name with netcdf attribute long_name
                long_name = nc[i].attrs['long_name']
                long_name = nc[i].attrs['long_name'].replace(',', '')
                self.long_name[i] = pd.Series([long_name])
                # append self.variables with netcdf variable names
                variables = i
                self.variables[i] = pd.Series([variables])
                var_list = [i] * len(self.asc[i].columns) ## Add the variable name to the column header
                self.asc[i].columns = pd.MultiIndex.from_tuples(zip(var_list,self.asc[i].columns, [units]))
                
            elif "sps1" in dims:
                self.histo = True
                histo_output = pd.DataFrame(nc[i][:, 0, :].values)
                self.asc[i] = pd.DataFrame(histo_output)
                # append self.units with netcdf attribute units
                units = nc[i].attrs['units']
                self.units[i] = pd.Series([units])
                # append self.long_name with netcdf attribute long_name
                long_name = nc[i].attrs['long_name'].replace(',', '')
                self.long_name[i] = pd.Series([long_name])
                # append self.variables with netcdf variable names
                variables = i
                self.variables[i] = pd.Series([variables])
                bin_cols =[]
                for num in self.asc[i].columns:
                    #check if list is empty
                    bin_cols.append(i+'_'+str(num))
                #print(bin_cols)
                self.asc[i].columns = pd.MultiIndex.from_tuples(zip(bin_cols, self.asc[i].columns, self.asc[i].columns))
                try:
                    cellsize = nc[i].attrs['CellSizes'] #TODO: Add cellsize to the ICARTT header and only have bin number in the column header
                    self.cellsize_dict[i] = cellsize
                    var_list = [i] * len(self.asc[i].columns) 
                    ## Add the bin number to variable name
                except KeyError:
                    var_list = [i] * len(self.asc[i].columns) ## Add the variable name to the column header
            else:
                pass
    # Define function to format the data loaded
    def formatData(self):
        return formatData(self)
    # Define function to populate variables in the table
    def loadVars_GUI(self):

        try:
            
            self.formatData()
            self.header_np = self.fileheader.to_numpy()
            self.row_count = (len(self.header_np))
            self.column_count = 3
            self.var.setColumnCount(self.column_count)
            self.var.setRowCount(self.row_count)
            for row in range(self.row_count):
                for column in range(self.column_count):
                    self.item = str(self.header_np[row, column])
                    self.var.setItem(row, column, QTableWidgetItem(self.item))
        except Exception as e:
            print(e)
            print(traceback.format_exc())
            print("error setting up the table")

    # Define function to select all variables in a NetCDF file
    def selectAll_GUI(self):

        self.formatData()
        self.asc_new = {}
        # iterate over the variables in the list
        try:
            for i in range(self.row_count):
                self.var.item(i, 0).setBackground(QtGui.QColor(71, 145, 209))
            del self.asc_new
            self.asc = self.asc
            self.previewData_GUI()
        except Exception:
            no_data = QMessageBox()
            no_data.setWindowTitle("Error")
            no_data.setText("There is no data to select all!")
            x = no_data.exec_()

    # Define function to deselect all variables, start from none
    def deselectAll_GUI(self):

        self.formatData()
        self.asc_new = {}
        self.loadVars_GUI()
        try:
            for i in range(self.row_count):
                self.var.item(i, 0).setBackground(QtGui.QColor(255, 255, 255))
            self.outputfilebox.setText(os.path.basename(self.output_file))
            self.outputpreview.clear()
            self.date1.setChecked(True)
            self.time1.setChecked(True)
            self.comma.setChecked(True)
            self.fillvalue1.setChecked(True)
            self.header1.setChecked(True)
            self.averagingbox.clear()
        except Exception:
            no_data = QMessageBox()
            no_data.setWindowTitle("Error")
            no_data.setText("Error Clearing Vars!")
            x = no_data.exec_()

    # Define function to select individual vars from list and populate fields
    def selectVars_GUI(self):

        # if there is a set of batch vars and user begins other selection, remove objects
        try:
            del(self.asc_new_batch)
            del(self.variables_extract_batch)
        except Exception as e:
            print(e)
            try:
                del(self.variables_extract_batch)
            except Exception as e:
                print(e)
        try:
            if self.batchfile_read:
                batchread = QMessageBox()
                batchread.setWindowTitle("Warning")
                batchread.setText("You are selecting vars after loading a batchfile! Please select vars in red if desired!")
                x = batchread.exec_()
            else:
                pass
        except Exception:
            pass

        try:
            self.output = pd.Series(self.var.item(self.var.currentRow(), 0).text())
            self.variables_extract = pd.concat([self.variables_extract, self.output], ignore_index=True)            
            self.variables_extract = self.variables_extract.drop_duplicates()
            self.asc_new = self.asc[self.variables_extract]
            nc = xr.open_dataset(self.input_file,decode_times=False)
            self.histo=False
            self.select_cellsize = {}
            for var in self.variables_extract:
                dims =str(nc[var].dims)
                if "sps1" in dims:
                    self.histo=True
                    self.select_cellsize[var]=self.cellsize_dict[var]
                    
        except Exception as e:
            self._log_exception(e)
            pass
        try:
            self.var_selected = str(self.asc_new.columns.values.tolist())
            self.var.item(self.var.currentRow(), 0).setBackground(QtGui.QColor(71, 145, 209))
            # need to remove the unwanted characters for the batch file
            self.var_selected = self.var_selected.replace('(', '')
            self.var_selected = self.var_selected.replace(')', '')
            self.var_selected = self.var_selected.replace("'", '')
            self.var_selected = self.var_selected.replace(',', '')
            self.var_selected = self.var_selected.replace('[', '')
            self.var_selected = self.var_selected.replace(']', '')
            self.previewData_GUI()
            self.batchfile_read = False
            return self.batchfile_read, self.asc_new, self.variables_extract, self.var_selected
        except Exception:
            print(traceback.format_exc())
            print("error in getting values from table")

    # Define function to deselect (clear) all vars selected
    def deselectVar_GUI(self):

        self.checkoutput = self.var.item(self.var.currentRow(), 0).text()
        if self.checkoutput in self.variables_extract.values:
            self.variables_extract = self.variables_extract.loc[self.variables_extract.values != self.checkoutput]
            self.asc_new = self.asc_new.drop(self.checkoutput, axis=1)
            self.var_selected = self.var_selected.replace(self.checkoutput, '')
            self.var.item(self.var.currentRow(), 0).setBackground(QtGui.QColor(255, 255, 255))
        else:
            pass
        self.previewData_GUI()
        return self.asc_new, self.variables_extract, self.var_selected

    # Define function to switch radio buttons to align with ICARTT or AMES selection
    def ICARTT_AMES_toggle_GUI(self):

        self.time3.setChecked(True)
        self.date3.setChecked(True)
        self.comma.setChecked(True)
        self.fillvalue1.setChecked(True)

    # Define function to update the output filename to adhere to ICARTT V2 standards
    def ICARTTfilename(self):
        try:
            self.data_date = str(self.dtime_sep[0].iloc[1])
            self.data_date = self.data_date.replace('-', ', ')
        except Exception:
            pass
        self.icartt_filename_date = self.data_date.replace(', ', '')
        try:
            self.icartt_filename = self.project_name + '-CORE_' + self.platform + '_' + self.icartt_filename_date + '_' + self.version + '.ict'
        except Exception:
            self.icartt_filename = self.project_name + '-CORE_' + self.platform + '_' + self.icartt_filename_date + '_RA.ict'
        try:
            self.outputfilebox.setText(self.icartt_filename)
        except Exception:
            return self.icartt_filename

    #########################################################################
    # Define function to format ICARTT header
    # Note: if used outside of this script, multiple vars needed
    # self.dtime, self.platform, self.project_name,
    # self.today, self.varNumber, self.output_file
    # also need header1.txt and header2.txt as templates
    #########################################################################

    #########################################################################
    # Define function to format AMES header
    ########################################################################

    #########################################################################
    # Define function to notify user that processing was successful.
    #########################################################################
    def processingSuccess_GUI(self):

        processing_complete = QMessageBox()
        processing_complete.setWindowTitle("Success!")
        ret = QMessageBox.question(self, 'Success!', "Data was written to the output file.", QMessageBox.Ok)

    #########################################################################
    # Define function to format the preview portion of the output file
    #########################################################################
    def formatPreview_GUI(self):

        with open(self.output_file) as preview:
            head = str(preview.readlines()[0:10])
            head = head.replace('\\n', '\n')
            head = head.replace('\\n', '\n')
            head = head.replace('[', '')
            head = head.replace(']', '')
            head = head.replace("', '", '')
            head = head.replace("'", '')
        self.outputpreview.setText(head)

    #########################################################################
    # Define function for handling date and time
    # Formatting for previewData_GUI and writeData functions
    #########################################################################
    def timeHandler(self, datasource):

        try:
            datasource.insert(loc=0, column='Time', value=self.dtime_time)
        except Exception:
            pass
        try:
            datasource.insert(loc=0, column='Date', value=self.dtime_date)
        except Exception:
            pass
        try:
            datasource.pop('DateTime')
        except Exception:
            pass
#############################################################################
# Function previewData_GUI creates an example output based on user settings and
# populates the Preview field in the gui. It is set up to autmatically update
# based on the selection of the vars in selectVars, selectAll_GUI, or deselectAll_GUI.
#############################################################################

    #########################################################################
    # Define function to preview data output within the app
    #########################################################################
    def previewData_GUI(self):
        # assign self.asc_new or self.asc to self.preview dataframe
        try:
            try:
                self.preview = self.asc_new_batch
            except Exception:
                self.preview = self.asc_new
        except Exception:
            self.preview = self.asc
        self.preview = round(self.preview, 5)
        # get the output file from the text box
        self.output_file = os.path.join(self.outputdirbox.text(), self.outputfilebox.text())
        # get the start and end times from the text box in the gui
        start = self.start.text()
        end = self.end.text()
        self.date = 'yyyy-mm-dd' if self.date1.isChecked() else 'yyyy mm dd' if self.date2.isChecked() else 'NoDate'
        self.time = 'hh:mm:ss' if self.time1.isChecked() else 'hh mm ss' if self.time2.isChecked() else 'SecOfDay'
        self.fillvalue = -32767 if self.fillvalue1.isChecked() else 'Blank' if self.fillvalue2.isChecked() else 'Replicate'
        self.delimiter = 'comma' if self.comma.isChecked() else 'space'
        self.header = 'Plain' if self.header1.isChecked() else 'ICARTT' if self.header2.isChecked() else 'AMES'
        try:
            # get the averaging information if it exists
            self.averaging_window = self.averagingbox.text()
            if len(self.averaging_window) != 0:
                self.averaging_window = int(self.averaging_window)
                self.preview = self.preview.rolling(self.averaging_window, min_periods=0).mean().round(decimals=0)
                self.preview = self.preview.iloc[::self.averaging_window, :]
            else:
                pass
            #################################################################
            # data and time combination checks for preview field
            ################################################################
            prev_vars = self.preview.columns.drop_duplicates
            self.preview=self.process_date_time(self.preview)
            print('Processed!')
            if self.header == 'Plain':
                PLAINHeader(self,self.preview.head(20))
                self.formatPreview_GUI()

            # ICARTT header
            elif self.header=='ICARTT':
                # drop the unit and dimension rows for ICARTT

                ICARTTHeader(self,self.preview)
                with open(self.output_file) as preview:
                    head = str(preview.readlines()[0:75])
                    head = head.replace('\\n', '\n')
                    head = head.replace('[', '')
                    head = head.replace(']', '')
                    head = head.replace("', '", '')
                    head = head.replace("'", '')
                self.outputpreview.setText(head)
            else:
                # drop the unit and dimension rows for AMES
                self.preview.columns = self.preview.columns.droplevel(1)
                self.preview.columns = self.preview.columns.droplevel(1)
                AMESHeader(self, self.preview)
                with open(self.output_file) as preview:
                    head = str(preview.readlines()[0:75])
                    head = head.replace('\\n', '\n')
                    head = head.replace('[', '')
                    head = head.replace(']', '')
                    head = head.replace("', '", '')
                    head = head.replace("'", '')
                self.outputpreview.setText(head)
        except Exception as e:
            print(e)
            processing_complete = QMessageBox()
            processing_complete.setWindowTitle("Error")
            processing_complete.setText("There was an error writing your ASCII file. Please try again.")
            x = processing_complete.exec_()
        else:
            pass
    ########################
    #Batchfile functions#
    #######################
    def saveBatchFile_GUI(self):
        return saveBatchFile_GUI(self)
    def process_batch_file(self, inputbatch_file):
        return process_batch_file(self, inputbatch_file)
    def readBatchFile(self):
        return readBatchFile(self)
    def process_date_time(self, dataframe):
        return process_date_time(self, dataframe)

    # end def
    #########################################################################
    # Define function to write data to output file
    #########################################################################
    def writeData(self):
        return writeData(self)        


#############################################################################
# nc2asc CL Class
#############################################################################
class nc2asc_CL():
    def __init__(self):
        self.guiMode = False
        self.histo = False
        self.timeHandler = gui.timeHandler
        self.input_file = False
        self.output_file = False
        self.inputbatch_file = False
        self.rate = False
        self.vars = False
        self.variables_extract_batch=[]
        self.cellsize_dict = {}
        self.version = 'RA' ##Defaults to field data unless overridden
    #inherit self._log_exception from nc2asc_GUI
        self.fillvalue = '-32767'
        self.delimiter = 'comma'
        self.date = 'yyyy-mm-dd'
        self.time = 'hh:mm:ss'
        self.header = 'Plain'
    def _log_exception(self, e):
        print(e)
        print(traceback.format_exc())
    def process_date_time(self, dataframe):
        return process_date_time(self, dataframe)
    def parse_args(self):
        # set up argument parsing
        parser = argparse.ArgumentParser(description='Provide (Optional) (-i) Input File (Optional) (-o) Output File and (-b) Batch File')
        # define input file(s) to process
        parser.add_argument('-b', type=str, help='Batch file')
        parser.add_argument('-i', type=str, help='(Optional) Input file to convert' + 'e.g. /scr/raf_data/<PROJECT>/PROJECTrf01.nc')
        parser.add_argument('-o', type=str, help='(Optional) Output file')
        parser.add_argument('-mixed_rate', action='store_true')
        parser.add_argument('-v', type=str, nargs='+', help='(Optional) Variables to convert with HRT or SRT conversion. Defaults to all.')
        args = parser.parse_args()
        return(args)
    
    def store_File(self,ln):
        filename = []
        filename = str(ln[2:])
        filename = filename.replace('=', '')
        filename = filename.replace("'", '')
        filename = filename.replace('\n', '')
        print(f'Using filename from the batch file: '+filename)
        return filename
    


    def _format_avg(self, avg):
        """Format the averaging value from the batch file."""
        return avg.translate({ord(c): None for c in "[]='g"}).strip()[:-1]
    
    def _format_avg(self, avg):
        """Format the averaging value from the batch file."""
        return avg.translate({ord(c): None for c in "[]='g"}).strip()[:-1]
        
    #######################################################################
    # Define processing function
    #######################################################################
    def processData(self, args):
        self.input_file = args.i if args.i else False
        self.output_file = args.o if args.o else False
        self.inputbatch_file = args.b if args.b else False
        try:
            self.rate = args.mixed_rate
        except Exception as e:
            self._log_exception(e)
            self.rate = False
        try:
            self.vars = args.v
        except Exception as e:
            self._log_exception(e)
        if self.input_file:
            print('INPUT FILE:' + self.input_file)
            # read in the input file
        if self.output_file:
            print('OUTPUT_FILE:' + self.output_file)
            
        if self.inputbatch_file:
            gui.process_batch_file(self,self.inputbatch_file)
            print(self.date)
        #Make sure evyerhing is set to defaults even if batchfile is provided.
        #Use ICARTT header by default
        else:
            self.variables_extract_batch =[]
            try:
                self.header2.setChecked(True)
            except:
                print("Using default header format: ICARTT")
                self.header = 'ICARTT'
            #Use yyyy-mm-dd by default
            try:
                self.date1.setChecked(True)
            except Exception:
                print("Using default date format: NoDate")
                self.date = 'NoDate'
            #Use hh:mm:ss by default
            try:
                self.time1.setChecked(True)
            except Exception:
                print("Using default time format: SecOfDay")
                self.time = 'SecOfDay'
            try:
                self.comma.setChecked(True)
            except Exception:
                print("Using default delimiter: comma")
                self.delimiter = 'comma'
            try:
                self.fillvalue2.setChecked(True)
            except Exception:
                print("Using default fill value: blank")
                self.fillvalue = 'blank'
        
        self.asc_new_batch = pd.DataFrame()

        # set default time and averaging: no averaging or time trimming
        self.ti = 'X,X'
        self.avg = ''
        
        nc = xr.open_dataset(self.input_file,decode_times=False)
        self.secofday = nc['Time'].values
        # keep mixed_rate bool arg, to enter this as opposed to the full conversion.
        if args.mixed_rate:

            # create placeholder dictionaries for dimensions and rate deltas

            variable_output = {}
            rate_delta_dict = {}
            asc = pd.DataFrame()
            temp_df = pd.DataFrame()
            variable_dimension_dict = {}

            # check to see if variables were included on command line
            if args.v is None:
                vars = nc.variables
            else:
                if 'Time' in args.v:
                    vars = args.v
                else:
                    args.v.insert(0, 'Time')
                    vars = args.v
            # iterate over vars
            for i in vars:

                # extract rates and append to dictionary
                dim = str(nc[i].dims).replace("('Time',)", str(1)).replace("('Time', 'sps", '').replace("')", '')
                variable_dimension_dict[i] = dim
                # find maximum rate
                value_list = variable_dimension_dict.values()

                # determine least common multiple for maximum rate, so no vals are lost
                lcm = list(value_list)[0]
                for i in range(1, len(value_list)):
                    lcm = int(lcm) * int(list(value_list)[i]) // math.gcd(int(lcm), int(list(value_list)[i]))

            # find the rate delta for each variable based on var dim and lcm dim
            for key, value in variable_dimension_dict.items():
                rate_delta_dict[key] = int(lcm) // int(value)
                print(str(key) + ' Rate: ' + str(value))
            # build the mixed rate dataframe
            for i in vars:
                variable_output = nc[i][:]
                temp_df = pd.DataFrame(variable_output.flatten())
                n = rate_delta_dict[i]
                mixed_rate_index = pd.RangeIndex(len(temp_df)*(n))
                reshape_asc = pd.DataFrame(np.nan, index=mixed_rate_index, columns=temp_df.columns)
                ids = np.arange(len(temp_df))*(n)
                reshape_asc.loc[ids] = temp_df.values
                asc = pd.concat([asc, reshape_asc], axis=1)
            asc.columns = [vars]
            # interpolate time in milliseconds for 100 Hz data if its there
            asc['Time'] = asc['Time'].interpolate()
            # forward fill mixed rate data
            asc = asc.ffill()
            # round to 5 significant digits
            asc = round(asc, 5)
            # keep trailing zeros for milliesconds in Time column
            time = np.array(asc['Time'])
            temp_time = []
            for i in time:
                i = "{:.3f}".format(float(i))
                temp_time.append(i)
            time = pd.DataFrame(temp_time, columns=['Time'])
            asc['Time'] = time['Time']
            # write to output file
            asc.to_csv(args.o, index=False)

        else:
            # create an empty pandas series to hold variables
            self.variables_extract = pd.Series(dtype='str')
            # create empty dicts
            self.asc = {}
            self.units = {}
            self.long_name = {}
            self.variables = {}
            self.fileheader = {}
            try:
                self.tail_number = nc.attrs['Platform']
            except KeyError:
                self.tail_number = nc.attrs['platform']
            if self.tail_number == 'N677F':
                self.platform = 'GV'
            elif self.tail_number == 'N130AR':
                self.platform = 'C130'
            self.project_name = nc.attrs['project']
            # After line 1008 where you set self.dtime = nc['Time'], add this section:
            if self.header == 'ICARTT':
                # Add Time_Start column as the first column for ICARTT format
                if not self.variables_extract_batch:
                    # Insert Time_Start at the beginning of the dataframe
                    self.asc_new_batch = self.asc.copy()
                    self.asc_new_batch.insert(0, 'Time_Start', self.secofday)
                    print('Added Time_Start column for ICARTT format')
                else:
                    # For batch processing, insert Time_Start at the beginning
                    self.asc_new_batch.insert(0, 'Time_Start', self.secofday)
                    print('Added Time_Start column for ICARTT format')
            else:
                # For non-ICARTT formats, proceed as normal
                if not self.variables_extract_batch:
                    print('Using all variables')
                    self.variables_extract_batch = list(nc.variables)  
                    self.asc_new_batch = self.asc
                else:
                    for x, var in enumerate(self.variables_extract_batch):
                        if var not in self.asc.columns:
                            print('***WARNING***Var '+str(var)+' not in netCDF file!!! Continuing with conversion****')
                    self.variables_extract_batch = [var for var in self.variables_extract_batch if var in self.asc.columns]
                    self.asc_new_batch = self.asc[self.variables_extract_batch]
            self.today = str(datetime.today().strftime('%Y, %m, %d'))
            self.today = self.today.replace('-', ', ')

            gui.parse_vars(self,nc)


            # concatenate
            print('****Concatenating Variables****')
            
            self.asc = pd.concat(self.asc, axis=1, ignore_index=False)
            self.asc.columns = self.asc.columns.droplevel(0) # Drop the first variable level that does not have bin numbers
            while isinstance(self.asc.columns, pd.MultiIndex):
                try:
                    self.asc.columns = self.asc.columns.droplevel(1)
                except IndexError:
                    break
            
            # create an object to store the netCDF variable time
            
            self.dtime = xr.coding.times.decode_cf_datetime(nc['Time'], nc['Time'].attrs['units'])
            self.dtime = pd.Series(self.dtime).astype(str)
            self.dtime_sep = self.dtime.str.split(' ', expand=True)
            # create separate date and time series for combination in previewData and writeData
            self.dtime_date = self.dtime_sep[0]
            self.dtime_time = self.dtime_sep[1]
            # concatenate the units, long_name, variables, and header
            self.units = pd.concat(self.units, axis=0, ignore_index=True)
            self.long_name = pd.concat(self.long_name, axis=0, ignore_index=True)
            self.variables = pd.concat(self.variables, axis=0, ignore_index=True)
            self.fileheader = pd.concat([self.variables, self.units, self.long_name], axis=1, ignore_index=True)
            # subset the start and end time from the dtime object by position
            self.start_time = self.dtime.iloc[0]
            self.end_time = self.dtime.iloc[-1]
            self.dtime = nc['Time']
            

            if not self.variables_extract_batch:
                print('Using all variables')
                self.variables_extract_batch = list(nc.variables)  
                self.asc_new_batch = self.asc

            else:
                for x, var in enumerate(self.variables_extract_batch):
                    if var not in self.asc.columns:
                        #Remove var from list if it is not in the netCDF file
                        
                        print('***WARNING***Var '+str(var)+' not in netCDF file!!! Continuing with conversion****')
                self.variables_extract_batch = [var for var in self.variables_extract_batch if var in self.asc.columns]
                self.asc_new_batch = self.asc[self.variables_extract_batch]
            try:
                for i in self.variables_extract_batch:
                    if i not in nc.variables:
                        print('***WARNING****Var '+str(i)+' not in netCDF file!!! Continuing with conversion****')
                    else:
                        pass
            except Exception as e:
                self._log_exception(e)
            try:
                gui.writeData(self)
                print('****Write Data Process Complete****')
            except Exception as e:
                self._log_exception(e)
            return self.asc, self.input_file, self.output_file, self.dtime_date, self.dtime_time, self.dtime


#############################################################################
# Define main function to determine mode
# Program can execute to render GUI or can process via command line
#############################################################################
def main():

    if len(sys.argv) > 1:
        try:
            cl = nc2asc_CL()
        except Exception as e:
            gui._log_exception(e)
        try:
            args = cl.parse_args()
        except Exception as e:
            gui._log_exception(e)
        try:
            cl.processData(args)
        except Exception as e:
            gui._log_exception(e+ ': Error processing data')
    else:
        app = QtWidgets.QApplication(sys.argv)
        app.setStyle('Windows')
        ex = gui()
        ex.show()
        sys.exit(app.exec_())


#############################################################################
# Call main function
#############################################################################
if __name__ == "__main__":

    main()
