#! /usr/bin/env python3
##############################################################################
# Conversion of original nc_sane written in C
#
# Additional feature to check that histogram data sum matches the
# Sum variable corresponding to that data
#
# Copyright University Corporation for Atmospheric Research (2022)
#
# Author: TMT
##############################################################################

import os
import sys
import re
import argparse
import xarray as xr
import datetime
from datetime import timedelta, datetime, date, time
import calendar
import numpy as np


def main():

    ncsane = ncSane()
    args = ncsane.parseArgs()
    ncsane.timeInterval(args)
    ncsane.startEndtime(args, ncsane.diff, ncsane.start, ncsane.end, ncsane.d)
    ncsane.recordNum_timeInterval_compare(args, ncsane.diff, ncsane.time)
    ncsane.checkBasetime(args, ncsane.timeformat)
    ncsane.histoCheck(args, ncsane.ds, ncsane.histo_count_list, ncsane.histo_count_list2, ncsane.histo_conc_list, ncsane.histo_conc_list2)

class ncSane():

    def timeInterval(self, args):
        """
        check to see that time interval attribute exists
        check to see that it is greater than 0
        """
        verbose = args.verbose
        for i in args.file_pattern:
            # use xarray to read netcdf file
            self.ds = xr.open_dataset(i)
            # store TimeInterval attribute for analysis
            self.ti = self.ds.attrs['TimeInterval']
            self.ti = self.ti.split("-")
            self.start = self.ti[0]
            self.end = self.ti[1]
            self.d = date(1900, 1, 1)
            self.start = datetime.strptime(self.start, '%H:%M:%S').time()
            self.end = datetime.strptime(self.end, '%H:%M:%S').time()
            if verbose == True:
                print('****************************************')
                print('Start Time: ' + str(self.start))
                print('End Time: ' + str(self.end))
            else:
                print('Time Interval Check: Pass')
            # calculate difference in time interval
            self.diff = datetime.combine(self.d, self.end) \
                - datetime.combine(self.d, self.start)
            # store other netcdf information for use by other functions
            # limit reading of netcdf to this function
            self.time = self.ds.dims['Time']
            self.timeformat = self.ds['Time'].attrs['strptime_format']

            # determine the lists of count and conc vars from file
            var_list = []
            self.variables = self.ds.keys()
            for i in self.variables:
                var_list.append(i)
            self.histo_count_list = []
            self.histo_count_list2 = []
            self.histo_conc_list = []
            self.histo_conc_list2 = []
            counts_pattern1 = ['ACDP', 'AUHSAS']
            counts_pattern2 = ['TCNTD', 'TCNTU']
            conc_pattern1 = ['CCDP', 'CUHSAS']
            conc_pattern2 = ['CONCD', 'CONCU']
            for i in var_list:
                for j in counts_pattern1:
                    if i.startswith(j):
                        self.histo_count_list.append(i)
                for k in conc_pattern1:
                    if i.startswith(k):
                        self.histo_conc_list.append(i)
                for l in counts_pattern2:
                    if i.startswith(l):
                        self.histo_count_list2.append(i)
                for m in conc_pattern2:
                    if i.startswith(m):
                        self.histo_conc_list2.append(i)        

            return(self.histo_count_list, self.histo_count_list2, self.histo_conc_list, self.histo_conc_list2, self.ds, self.ti, self.timeformat, self.time,
                   self.diff, self.d, self.start, self.end)

    def startEndtime(self, args, diff, start, end, d):
        """
        check to see that the end time is after the start time
        account for midnight rollover
        """
        verbose = args.verbose
        if end < start:
            if verbose == True:
                print('****************************************')
                print('Midnight Rollover was detected, end time was less than start time...')
            else:
                print('Midnight Rollover Check: Detected')
            midnight = str(end).replace('1', '0').replace('2', '0')\
            .replace('3', '0').replace('4', '0').replace('5', '0')\
            .replace('6', '0').replace('7', '0').replace('8', '0')\
            .replace('9', '0')
            midnight = datetime.strptime(midnight, '%H:%M:%S').time()
            midnight = datetime.combine(d, midnight)
            diff1 = datetime.combine(d, end) - midnight
            diff2 = midnight - datetime.combine(d, start)
            diff2 = diff2 + timedelta(hours=24)
            self.diff = (diff1 + diff2)
            if verbose == True:
                print('Flight Duration: ' + str(self.diff))
                print('****************************************')
            else:
                pass
        else:
            if verbose == True:
                print('****************************************')
                print('No midnight rollover detected.')
                print('Flight Duration: ' + str(self.diff))
                print('****************************************')
            else:
                print('Midnight Rollover Check: Not Detected')
        return self.diff

    def recordNum_timeInterval_compare(self, args, diff, time):
        """
        check record num matches the time interval difference
        account for midnight rollover
        """
        verbose = args.verbose
        if verbose == True:
            print('Flight Duration (seconds): ' + str(int(diff.total_seconds())))
            print('Reported Time dimension range (seconds): ' + str(int(time)))
        else:
            pass
        time_diff = int(diff.total_seconds()) - int(time)
        if abs(time_diff) < 2:
            if verbose == True:
                print('Reported time interval and calculated time interval match!')
            else:
                print('Time Interval Check: Pass')
        else:
            if verbose == True:
                print('Reported and calculated time interval do NOT match!')
            else:
                print('Time Interval Check: Fail')
    def checkBasetime(self, args, timeformat):
        """
        check basetime is correct
        """
        verbose = args.verbose
        if timeformat == "seconds since %F %T %z":
            if verbose == True:
                print('****************************************')
                print('Time format is correct: ' + timeformat)
                print('****************************************')
            else:
                print('Base Time Check: Pass')
        else:
            if verbose == True:
                print('Time format does not match: ' + timeformat)
                print('****************************************')
            else:
                print('Base Time Check: Fail')
    def parseArgs(self):
        """
        Set up argument parsing
        """
        parser = argparse.ArgumentParser(
            description='Provide input file, histogram var and total var.')

        parser.add_argument('file_pattern', type=str, nargs='*',
                            help='Input file to check' +
                            'e.g. /scr/raf_data/<PROJECT>/PROJECTrf01.nc')
        parser.add_argument('-v', '--verbose', action='store_true', 
                            help="flag for verbose output")

        if len(sys.argv) < 1:
            parser.print_help(sys.stderr)
            sys.exit(1)
        self.args = parser.parse_args()
        return(self.args)

    def histoVarSetup(self, ds, index, histo1, histo2, histo3, histo4):
        try:
            self.da_counts = ds[histo1[index]]
            self.da_long_name_counts = self.da_counts.long_name
            self.da_counts = self.da_counts.values
        except Exception as e:
            print(e)
        try:
            self.da_compare_counts = ds[histo2[index]]
            self.da_compare_long_name_counts = self.da_compare_counts.long_name
            self.da_compare_counts = self.da_compare_counts.values
        except Exception as e:
            print(e)
        try:
            self.da_conc = ds[histo3[index]]
            self.da_long_name_conc = self.da_conc.long_name
            self.da_conc = self.da_conc.values
        except Exception as e:
            print(e)
        try:
            self.da_compare_conc = ds[histo4[index]]
            self.da_compare_long_name_conc = self.da_compare_conc.long_name
            self.da_compare_conc = self.da_compare_conc.values
        except Exception as e:
            print(e)

        return(self.da_counts, self.da_long_name_counts, self.da_compare_counts,
               self.da_compare_long_name_counts, self.da_conc,
               self.da_long_name_conc, self.da_compare_conc, self.da_compare_long_name_conc)

    def histoLoop(self, args, da_counts, da_compare_counts,
                  da_compare_long_name_counts, da_conc, da_compare_conc, da_compare_long_name_conc, da_long_name_counts, da_long_name_conc):
            verbose = self.args.verbose
            if verbose == True:
                print('Starting histogram checking: ' + str(da_compare_long_name_counts))
            else:
                pass
            # loop over time dimension to calculate sum
            for i in range(0, len(da_counts)):
                # calculate sum from histo var and check if matches reported total
                if np.sum(da_counts[i]) == da_compare_counts[i]:
                    pass
                # handle cases where there are missing or nan values
                else:
                    if da_compare_counts[i] == -32767.:
                        pass
                    elif str(da_compare_counts[i]) == 'nan':
                        pass
                    elif str(np.sum(da_compare_counts[i])) == 'nan':
                        pass
                    # report if the sum values do not match
                    else:
                        # handle float rounding errors
                        if np.sum(da_counts[i]) - da_compare_counts[i] < .01:
                            pass
                        # report failure
                        else:
                            if verbose == True:
                                print('Error on line: ' + str(i) + ' Calculated total for ' +
                                str(da_compare_long_name_counts) + ' at time: ' + str(time[i]) + ': ' +
                                str(np.sum(da_counts[i])) + ' Reported total for ' + ' ' +
                                str(da_compare_long_name_counts) + ' at time: ' + str(time[i]) + ': ' +
                                str(da_compare_counts[i]))
                            else:
                                print('Histogram Check: Failed on line' + str(i) +'. Run with -v for verbose mode.')
            if verbose == True:
                print('Done with histogram checking: ' + str(da_compare_long_name_counts))
                print('****************************************')
            if verbose == True:
                print('Starting histogram checking: ' + str(da_compare_long_name_conc))
            else:
                pass
            # loop over time dimension to calculate sum
            for i in range(0, len(da_conc)):
                # calculate sum from histo var and check if matches reported total
                if np.sum(da_conc[i]) == da_compare_conc[i]:
                    pass
                # handle cases where there are missing or nan values
                else:
                    if da_compare_conc[i] == -32767.:
                        pass
                    elif str(da_compare_conc[i]) == 'nan':
                        pass
                    elif str(np.sum(da_compare_conc[i])) == 'nan':
                        pass
                    # report if the sum values do not match
                    else:
                        # handle float rounding errors
                        if np.sum(da_conc[i]) - da_compare_conc[i] < .01:
                            pass
                        # report failure
                        else:
                            if verbose == True:
                                print('Error on line: ' + str(i) + ' Calculated total not equal to reported total')
                            else:
                                print('Histogram Check: Failed Run with -v for verbose mode.')
            if verbose == True:
                print('Done with histogram checking: ' + str(da_compare_long_name_conc))
                print('****************************************')
            else:
                pass

    def histoCheck(self, args, ds, histo1, histo2, histo3, histo4):
        """
        Function that reads input file, histogram variable, total variable
        and performs sum of the counts / concentration values present in
        the histogram data. Handles missing values, NaN, and close differences
        introduced due to float precision.

        Reports falied lines and the time on the command line.
        """
        # read input file, histogram count data, and total count for comparison
        input_file = args.file_pattern
        verbose = args.verbose
        time = ds["Time"].values
        index = 0
        if index == 0:
            try:
                self.histoVarSetup(ds, index, self.histo_count_list, self.histo_count_list2, self.histo_conc_list, self.histo_conc_list2)
            except Exception as e:
                print(e)
            try:
                self.histoLoop(args, self.da_counts, self.da_compare_counts, self.da_compare_long_name_counts, self.da_conc, self.da_compare_conc, self.da_compare_long_name_conc, self.da_long_name_counts, self.da_long_name_conc)
            except Exception as e:
                print(e)
            index = index +1
        if index == 1:
            try:
                self.histoVarSetup(ds, index, self.histo_count_list, self.histo_count_list2, self.histo_conc_list, self.histo_conc_list2)
            except Exception as e:
                print(e)
            try:
                self.histoLoop(args, self.da_counts, self.da_compare_counts, self.da_compare_long_name_counts, self.da_conc, self.da_compare_conc, self.da_compare_long_name_conc, self.da_long_name_counts, self.da_long_name_conc)
            except Exception as e:
                print(e)
if __name__ == "__main__":
    main()
