#! /usr/bin/env python3
##############################################################################
# Conversion of original nc_sane written in C
#
# Additional feature to check that histogram data sum matches the
# Sum variable corresponding to that data
#
# Copyright University Corporation for Atmospheric Research (2022)
#
# Author: TMT
##############################################################################

import os
import sys
import argparse
import xarray as xr
import datetime
from datetime import timedelta, datetime, date, time
import calendar
import numpy as np


def main():

    ncsane = ncSane()
    args = ncsane.parseArgs()
    ncsane.timeInterval(args)
    ncsane.startEndtime(ncsane.diff, ncsane.start, ncsane.end, ncsane.d)
    ncsane.recordNum_timeInterval_compare(ncsane.diff, ncsane.time)
    ncsane.checkBasetime(ncsane.timeformat)
    ncsane.histoCheck(args, ncsane.ds)
    try:
        ncsane.histoCheck2(ncsane.da_counts, ncsane.da_compare_counts, ncsane.da_compare_long_name_counts, ncsane.ds)
    except Exception as e:
        print(e)
    try:
        ncsane.histoCheck2(ncsane.da_conc, ncsane.da_compare_conc, ncsane.da_compare_long_name_conc, ncsane.ds)
    except Exception as e:
        print(e)
class ncSane():

    def timeInterval(self, args):
        """
        check to see that time interval attribute exists
        check to see that it is greater than 0
        """
        for i in args.file_pattern:
            # use xarray to read netcdf file
            self.ds = xr.open_dataset(i)
            # store TimeInterval attribute for analysis
            self.ti = self.ds.attrs['TimeInterval']
            self.ti = self.ti.split("-")
            self.start = self.ti[0]
            self.end = self.ti[1]
            self.d = date(1900, 1, 1)
            self.start = datetime.strptime(self.start, '%H:%M:%S').time()
            self.end = datetime.strptime(self.end, '%H:%M:%S').time()
            print('Start Time: ' + str(self.start))
            print('End Time: ' + str(self.end))
            # calculate difference in time interval
            self.diff = datetime.combine(self.d, self.end) \
                - datetime.combine(self.d, self.start)
            # store other netcdf information for use by other functions
            # limit reading of netcdf to this function
            self.time = self.ds.dims['Time']
            self.timeformat = self.ds['Time'].attrs['strptime_format']
            return(self.ds, self.ti, self.timeformat, self.time,
                   self.diff, self.d, self.start, self.end)

    def startEndtime(self, diff, start, end, d):
        """
        check to see that the end time is after the start time
        account for midnight rollover
        """
        if end < start:
            print('Midnight rollover detected.')
            midnight = str(end).replace('1', '0').replace('2', '0')\
                .replace('3', '0').replace('4', '0').replace('5', '0')\
                .replace('6', '0').replace('7', '0').replace('8', '0')\
                .replace('9', '0')
            midnight = datetime.strptime(midnight, '%H:%M:%S').time()
            midnight = datetime.combine(d, midnight)
            diff1 = datetime.combine(d, end) - midnight
            diff2 = midnight - datetime.combine(d, start)
            diff2 = diff2 + timedelta(hours=24)
            self.diff = (diff1 + diff2)
            print('Flight Duration: ' + str(self.diff))

        else:
            print('No midnight rollover detected.')
            print('Flight Duration: ' + str(self.diff))
        return self.diff

    def recordNum_timeInterval_compare(self, diff, time):
        """
        check record num matches the time interval difference
        account for midnight rollover
        """
        print('Flight Duration (seconds): ' + str(int(diff.total_seconds())))
        print('Reported Time dimension range (seconds): ' + str(int(time)))
        time_diff = int(diff.total_seconds()) - int(time)
        if abs(time_diff) < 2:
            print('Reported time interval and calculated time interval match!')

        else:
            print('Reported and calculated time interval do NOT match!')

    def checkBasetime(self, timeformat):
        """
        check basetime is correct
        """

        if timeformat == "seconds since %F %T %z":
            print('Time format is correct: ' + timeformat)
        else:
            print('Time format does not match: ' + timeformat)

    def parseArgs(self):
        """
        Set up argument parsing
        """
        parser = argparse.ArgumentParser(
            description='Provide input file, histogram var and total var.')

        parser.add_argument('file_pattern', type=str, nargs='*',
                            help='Input file to check' +
                            'e.g. /scr/raf_data/<PROJECT>/PROJECTrf01.nc')

        #parser.add_argument('verbosity', type=str, help='Verbose output')

        #parser.add_argument('histo_var', type=str, help='Histogram variable')
        #parser.add_argument('total_var', type=str, help='Total variable')

        if len(sys.argv) < 1:
            parser.print_help(sys.stderr)
            sys.exit(1)
        self.args = parser.parse_args()
        return(self.args)

    def histoCheck(self, args, ds):
        """
        Function that reads input file, histogram variable, total variable
        and performs sum of the counts / concentration values present in
        the histogram data. Handles missing values, NaN, and close differences
        introduced due to float precision.

        Reports falied lines and the time on the command line.
        """
        #print('Starting histo checks using histogram var: ' + args.histo_var + ' and total var: ' + args.total_var)
        # read input file, histogram count data, and total count for comparison
        input_file = args.file_pattern

        try:
            try:
                self.da_counts = ds['ACDP_LWOO']
                self.da_compare_counts = ds['TCNTD_LWOO']
                self.da_long_name_counts = self.da_counts.long_name
                self.da_counts = self.da_counts.values
                self.da_compare_long_name_counts = self.da_compare_counts.long_name
                self.da_compare_counts = self.da_compare_counts.values
            except Exception as e:
                print(e)
            try:
                self.da_conc = ds['CCDP_LWOO']
                self.da_compare_conc = ds['CONCD_LWOO']
                self.da_long_name_conc = self.da_conc.long_name
                self.da_conc = self.da_conc.values
                self.da_compare_long_name_conc = self.da_compare_conc.long_name
                self.da_compare_conc = self.da_compare_conc.values
            except Exception as e:
                print(e)
        except Exception as e:
            print(e)
        return(self.da_counts, self.da_compare_long_name_counts, self.da_compare_counts, self.da_conc, self.da_compare_conc, self.da_compare_long_name_conc)

    def histoCheck2(self, da, da_compare, da_compare_long_name, ds):

        time = ds["Time"].values
        # loop over time dimension to calculate sum
        for i in range(0, len(da)):
            # calculate sum from histo var and check if matches reported total
            if np.sum(da[i]) == da_compare[i]:
                pass
            # handle cases where there are missing or nan values
            else:
                if da_compare[i] == -32767.:
                    pass
                elif str(da_compare[i]) == 'nan':
                    pass
                elif str(np.sum(da_compare[i])) == 'nan':
                    pass
                # report if the sum values do not match
                else:
                    # handle float rounding errors
                    if np.sum(da[i]) - da_compare[i] < .01:
                        pass
                    # report failure
                    else:
                        print('Calculated total for ' + str(da_long_name) + ' at time: '
                              + str(time[i]) + ', row :' + str(i) + ': '
                              + str(np.sum(da[i])))
                        print('Reported total for ' + ' ' + str(da_compare_long_name) +
                              ' at time: ' + str(time[i]) + ', row '
                              + str(i) + ': ' + str(da_compare[i]))
                        print('*Failed histogram checker*')
        print('Done with histogram checking: ' + str(da_compare_long_name))

if __name__ == "__main__":
    main()
